<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Llvm.NET</name>
  </assembly>
  <members>
    <member name="T:Llvm.NET.AttributeKind">
      <summary>Enumeration for well known attribute kinds</summary>
    </member>
    <member name="T:Llvm.NET.ByteOrdering">
      <summary>Byte ordering for target code generation and data type layout</summary>
    </member>
    <member name="T:Llvm.NET.CallingConvention">
      <summary>Calling Convention for functions</summary>
    </member>
    <member name="T:Llvm.NET.CodeGenFileType">
      <summary>Output file type for target code generation</summary>
    </member>
    <member name="T:Llvm.NET.CodeGenOpt">
      <summary>Optimization level for target code generation</summary>
    </member>
    <member name="T:Llvm.NET.CodeModel">
      <summary>Code model to use for target code generation</summary>
    </member>
    <member name="T:Llvm.NET.ConstantAsMetadata"></member>
    <member name="T:Llvm.NET.Context">
      <summary>Encapsulates an LLVM context</summary>
    </member>
    <member name="M:Llvm.NET.Context.#ctor">
      <summary>Creates a new context</summary>
    </member>
    <member name="P:Llvm.NET.Context.BoolType">
      <summary>Get's the LLVM boolean type for this context</summary>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(Llvm.NET.Types.ITypeRef,System.UInt64,System.Boolean)">
      <summary>Create a constant value of the specified integer type</summary>
      <param name="intType">Integer type</param>
      <param name="constValue">value</param>
      <param name="signExtend">flag to indicate if <paramref name="constValue" /> is sign extended</param>
      <returns>Constant for the specified value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.Boolean)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 1</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.Byte)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 8</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.Double)">
      <summary>Creates a constant floating point value for a given value</summary>
      <param name="constValue">Value to make into a <see cref="T:Llvm.NET.Values.ConstantFP" /></param>
      <returns>Constant value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.Int16)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 16</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.Int32)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 32</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.Int64)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 64</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.SByte)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 8</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.Single)">
      <summary>Creates a constant floating point value for a given value</summary>
      <param name="constValue">Value to make into a <see cref="T:Llvm.NET.Values.ConstantFP" /></param>
      <returns>Constant value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.UInt16)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 16</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.UInt32)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 32</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.UInt32,System.UInt64,System.Boolean)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 64</summary>
      <param name="bitWidth">Bit width of the integer</param>
      <param name="constValue">Value for the constant</param>
      <param name="signExtend">flag to indicate if the const value should be sign extended</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstant(System.UInt64)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt" /> with a bit length of 64</summary>
      <param name="constValue">Value for the constant</param>
      <returns>
        <see cref="T:Llvm.NET.Values.ConstantInt" /> representing the value</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstantString(System.String)">
      <summary>Create a constant data string value</summary>
      <param name="value">string to convert into an LLVM constant value</param>
      <returns>new <see cref="T:Llvm.NET.Values.ConstantDataArray" /></returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstantString(System.String,System.Boolean)">
      <summary>Create a constant data string value</summary>
      <param name="value">string to convert into an LLVM constant value</param>
      <param name="nullTerminate">flag to indicate if the string should include a null terminator</param>
      <returns>new <see cref="T:Llvm.NET.Values.ConstantDataArray" /></returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstantStruct(System.Boolean,Llvm.NET.Values.Constant[])">
      <summary>Creates a constant structure from a set of values</summary>
      <param name="packed">Flag to indicate if the structure is packed and no alignment should be applied to the members</param>
      <param name="values">Set of values to use in forming the structure</param>
      <returns>Newly created <see cref="T:Llvm.NET.Values.Constant" /></returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateConstantStruct(System.Boolean,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Constant})">
      <summary>Creates a constant structure from a set of values</summary>
      <param name="values">Set of values to use in forming the structure</param>
      <param name="packed">Flag to indicate if the structure is packed and no alignment should be applied to the members</param>
      <returns>Newly created <see cref="T:Llvm.NET.Values.Constant" /></returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateFunctionType(Llvm.NET.DebugInfo.DebugInfoBuilder,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}[])">
      <summary>Creates a FunctionType with Debug information</summary>
      <param name="diBuilder">
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder" />to use to create the debug information</param>
      <param name="retType">Return type of the function</param>
      <param name="argTypes">Argument types of the function</param>
      <returns>Function signature</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateFunctionType(Llvm.NET.DebugInfo.DebugInfoBuilder,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}})">
      <summary>Creates a FunctionType with Debug information</summary>
      <param name="diBuilder">
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder" />to use to create the debug information</param>
      <param name="retType">Return type of the function</param>
      <param name="argTypes">Argument types of the function</param>
      <returns>Function signature</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateFunctionType(Llvm.NET.DebugInfo.DebugInfoBuilder,System.Boolean,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}[])">
      <summary>Creates a FunctionType with Debug information</summary>
      <param name="diBuilder">
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder" />to use to create the debug information</param>
      <param name="isVarArg">Flag to indicate if this function is variadic</param>
      <param name="retType">Return type of the function</param>
      <param name="argTypes">Argument types of the function</param>
      <returns>Function signature</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateFunctionType(Llvm.NET.DebugInfo.DebugInfoBuilder,System.Boolean,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}})">
      <summary>Creates a FunctionType with Debug information</summary>
      <param name="diBuilder">
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder" />to use to create the debug information</param>
      <param name="isVarArg">Flag to indicate if this function is variadic</param>
      <param name="retType">Return type of the function</param>
      <param name="argTypes">Argument types of the function</param>
      <returns>Function signature</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateMetadataString(System.String)">
      <summary>Creates a metadata string from the given string</summary>
      <param name="value">string to create as metadata</param>
      <returns>new metadata string</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateNamedConstantStruct(Llvm.NET.Types.IStructType,Llvm.NET.Values.Constant[])">
      <summary>Creates a constant instance of a specified structure type from a set of values</summary>
      <param name="type">Type of the structure to create</param>
      <param name="values">Set of values to use in forming the structure</param>
      <returns>Newly created <see cref="T:Llvm.NET.Values.Constant" /></returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateNamedConstantStruct(Llvm.NET.Types.IStructType,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Constant})">
      <summary>Creates a constant instance of a specified structure type from a set of values</summary>
      <param name="type">Type of the structure to create</param>
      <param name="values">Set of values to use in forming the structure</param>
      <returns>Newly created <see cref="T:Llvm.NET.Values.Constant" /></returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateStructType(System.Boolean,Llvm.NET.Types.ITypeRef,Llvm.NET.Types.ITypeRef[])">
      <summary>Create an anonymous structure type (e.g. Tuple)</summary>
      <param name="packed">Flag to indicate if the structure is "packed"</param>
      <param name="element0">Type of the first field of the structure</param>
      <param name="elements">Types of any additional fields of the structure</param>
      <returns>
        <see cref="T:Llvm.NET.Types.IStructType" /> with the specified body defined.
            </returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateStructType(System.String)">
      <summary>Create an empty structure type</summary>
      <param name="name">Name of the type</param>
      <returns>New type</returns>
    </member>
    <member name="M:Llvm.NET.Context.CreateStructType(System.String,System.Boolean,Llvm.NET.Types.ITypeRef[])">
      <summary>Creates a new structure type in this <see cref="T:Llvm.NET.Context" /></summary>
      <param name="name">Name of the structure</param>
      <param name="packed">Flag indicating if the structure is packed</param>
      <param name="elements">Types for the structures elements in layout order</param>
      <returns>
        <see cref="T:Llvm.NET.Types.IStructType" /> with the specified body defined.
            </returns>
    </member>
    <member name="P:Llvm.NET.Context.CurrentContext">
      <summary>Current context for the current thread</summary>
    </member>
    <member name="M:Llvm.NET.Context.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.Context</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Llvm.NET.Context.DoubleType">
      <summary>Get's the LLVM double precision floating point type for this context</summary>
    </member>
    <member name="M:Llvm.NET.Context.Finalize"></member>
    <member name="P:Llvm.NET.Context.FloatType">
      <summary>Get's the LLVM single precision floating point type for this context</summary>
    </member>
    <member name="M:Llvm.NET.Context.GetFunctionType(Llvm.NET.Types.ITypeRef,Llvm.NET.Types.ITypeRef[])">
      <summary>Get an LLVM Function type (e.g. signature)</summary>
      <param name="returnType">Return type of the function</param>
      <param name="args">Optional set of function argument types</param>
      <returns>Signature type for the specified signature</returns>
    </member>
    <member name="M:Llvm.NET.Context.GetFunctionType(Llvm.NET.Types.ITypeRef,System.Collections.Generic.IEnumerable{Llvm.NET.Types.ITypeRef})">
      <summary>Get an LLVM Function type (e.g. signature)</summary>
      <param name="returnType">Return type of the function</param>
      <param name="args">Potentially empty set of function argument types</param>
      <returns>Signature type for the specified signature</returns>
    </member>
    <member name="M:Llvm.NET.Context.GetFunctionType(Llvm.NET.Types.ITypeRef,System.Collections.Generic.IEnumerable{Llvm.NET.Types.ITypeRef},System.Boolean)">
      <summary>Get an LLVM Function type (e.g. signature)</summary>
      <param name="returnType">Return type of the function</param>
      <param name="args">Potentially empty set of function argument types</param>
      <param name="isVarArgs">Flag to indicate if the method supports C/C++ style VarArgs</param>
      <returns>Signature type for the specified signature</returns>
    </member>
    <member name="M:Llvm.NET.Context.GetIntType(System.UInt32)">
      <summary>Get's an LLVM integer type of arbitrary bit width</summary>
    </member>
    <member name="M:Llvm.NET.Context.GetPointerTypeFor(Llvm.NET.Types.ITypeRef)">
      <summary>Get a type that is a pointer to a value of a given type</summary>
      <param name="elementType">Type of value the pointer points to</param>
      <returns>
        <see cref="T:Llvm.NET.Types.IPointerType" /> for a pointer that references a value of type <paramref name="elementType" /></returns>
    </member>
    <member name="P:Llvm.NET.Context.HalfFloatType">
      <summary>Get's the LLVM half precision floating point type for this context</summary>
    </member>
    <member name="P:Llvm.NET.Context.Int16Type">
      <summary>Get's the LLVM 16 bit integer type for this context</summary>
    </member>
    <member name="P:Llvm.NET.Context.Int32Type">
      <summary>Get's the LLVM 32 bit integer type for this context</summary>
    </member>
    <member name="P:Llvm.NET.Context.Int64Type">
      <summary>Get's the LLVM 64 bit integer type for this context</summary>
    </member>
    <member name="P:Llvm.NET.Context.Int8Type">
      <summary>Get's the LLVM 8 bit integer type for this context</summary>
    </member>
    <member name="P:Llvm.NET.Context.IsDisposed">
      <summary>Flag to indicate if this instance is still valid</summary>
    </member>
    <member name="P:Llvm.NET.Context.Metadata">
      <summary>Gets an enumerable collection of all the metadata created in this context</summary>
    </member>
    <member name="P:Llvm.NET.Context.VoidType">
      <summary>Get's the LLVM void type for this context</summary>
    </member>
    <member name="T:Llvm.NET.ContextValidator">
      <summary>Provides validation extensions to the <see cref="T:Llvm.NET.Context" /> class</summary>
    </member>
    <member name="M:Llvm.NET.ContextValidator.Verify(Llvm.NET.Context,System.String,System.String,System.Action{System.String,System.String})">
      <summary>Execute a given action if the <see cref="T:Llvm.NET.Context" /> is <see langword="null" /> or is disposed</summary>
      <param name="context">
        <see cref="T:Llvm.NET.Context" />to test</param>
      <param name="name">Argument name or <see langword="null" /> if name is not needed by the supplied <paramref name="failAction" /></param>
      <param name="message">Error message for the <paramref name="failAction" /></param>
      <param name="failAction">Action to perform if the verification fails</param>
    </member>
    <member name="M:Llvm.NET.ContextValidator.VerifyAsArg(Llvm.NET.Context,System.String)">
      <summary>Throw an <see cref="T:System.ArgumentException" /> if the <see cref="T:Llvm.NET.Context" /> is <see langword="null" /> or is disposed</summary>
      <param name="context">
        <see cref="T:Llvm.NET.Context" />to test</param>
      <param name="name">Argument name</param>
    </member>
    <member name="M:Llvm.NET.ContextValidator.VerifyAsArg(Llvm.NET.Context,System.String,System.String)">
      <summary>Throw an <see cref="T:System.ArgumentException" /> if the <see cref="T:Llvm.NET.Context" /> is <see langword="null" /> or is disposed</summary>
      <param name="context">
        <see cref="T:Llvm.NET.Context" />to test</param>
      <param name="name">Argument name</param>
      <param name="message">Error message for the exception</param>
    </member>
    <member name="M:Llvm.NET.ContextValidator.VerifyOperation(Llvm.NET.Context)">
      <summary>Throw an <see cref="T:System.InvalidOperationException" /> if the <see cref="T:Llvm.NET.Context" /> is <see langword="null" /> or is disposed</summary>
      <param name="context">
        <see cref="T:Llvm.NET.Context" />to test</param>
    </member>
    <member name="M:Llvm.NET.ContextValidator.VerifyOperation(Llvm.NET.Context,System.String)">
      <summary>Throw an <see cref="T:System.InvalidOperationException" /> if the <see cref="T:Llvm.NET.Context" /> is <see langword="null" /> or is disposed</summary>
      <param name="context">
        <see cref="T:Llvm.NET.Context" />to test</param>
      <param name="message">Error message for the exception</param>
    </member>
    <member name="T:Llvm.NET.DataLayout">
      <summary>Provides access to LLVM target data layout information</summary>
    </member>
    <member name="M:Llvm.NET.DataLayout.AbiAlignmentOf(Llvm.NET.Types.ITypeRef)">
      <summary>Retrieves the ABI specified alignment, in bytes, for a specified type</summary>
      <param name="typeRef">Type to get the alignment for</param>
      <returns>ABI specified alignment</returns>
    </member>
    <member name="M:Llvm.NET.DataLayout.AbiBitAlignmentOf(Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.DataLayout.AbiSizeOf(Llvm.NET.Types.ITypeRef)">
      <summary>Retrieves the ABI specified size of the given type</summary>
      <param name="typeRef">Type to get the size from</param>
      <returns>Size of the type</returns>
    </member>
    <member name="M:Llvm.NET.DataLayout.BitOffsetOfElement(Llvm.NET.Types.IStructType,System.UInt32)"></member>
    <member name="M:Llvm.NET.DataLayout.BitSizeOf(Llvm.NET.Types.ITypeRef)">
      <summary>Returns the number of bits necessary to hold the specified type.</summary>
      <param name="typeRef">Type to retrieve the size of</param>
    </member>
    <member name="M:Llvm.NET.DataLayout.ByteSizeOf(Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.DataLayout.CallFrameAlignmentOf(Llvm.NET.Types.ITypeRef)">
      <summary>Retrieves the call frame alignment for a given type</summary>
      <param name="typeRef">type to get the alignment of</param>
      <returns>Alignment for the type</returns>
    </member>
    <member name="P:Llvm.NET.DataLayout.Context">
      <summary>Context used for this data (in particular, for retrieving pointer types)</summary>
    </member>
    <member name="M:Llvm.NET.DataLayout.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.DataLayout</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.DataLayout.Dispose(System.Boolean)">
      <summary>
        <markup>
          <include item="SMCAutoDocDisposeBool">
            <parameter>Llvm.NET.DataLayout</parameter>
          </include>
        </markup>
      </summary>
      <param name="disposing">
        <markup>
          <include item="SMCAutoDocDisposeParam">
            <parameter>Llvm.NET.DataLayout</parameter>
          </include>
        </markup>
      </param>
    </member>
    <member name="M:Llvm.NET.DataLayout.ElementAtOffset(Llvm.NET.Types.IStructType,System.UInt64)"></member>
    <member name="P:Llvm.NET.DataLayout.Endianess">
      <summary>Retrieves the byte ordering for this target</summary>
    </member>
    <member name="M:Llvm.NET.DataLayout.Finalize"></member>
    <member name="M:Llvm.NET.DataLayout.IntPtrType">
      <summary>Retrieves an LLVM integer type with the same bit width as
            a pointer for the default address space of the target</summary>
      <returns>Integer type matching the bit width of a native pointer in the target's default address space</returns>
    </member>
    <member name="M:Llvm.NET.DataLayout.IntPtrType(System.UInt32)">
      <summary>Retrieves an LLVM integer type with the same bit width as
            a pointer for the given address space of the target</summary>
      <returns>Integer type matching the bit width of a native pointer in the target's address space</returns>
    </member>
    <member name="M:Llvm.NET.DataLayout.OffsetOfElement(Llvm.NET.Types.IStructType,System.UInt32)"></member>
    <member name="M:Llvm.NET.DataLayout.Parse(Llvm.NET.Context,System.String)">
      <summary>Parses an LLVM target layout string</summary>
      <param name="context">
        <see cref="P:Llvm.NET.DataLayout.Context" /> for types created by the new <see cref="T:Llvm.NET.DataLayout" /></param>
      <param name="layout">string to parse</param>
      <returns>Parsed target data</returns>
    </member>
    <member name="M:Llvm.NET.DataLayout.PointerSize">
      <summary>Retrieves the size of a pointer for the default address space of the target</summary>
      <returns>Size of a pointer to the default address space</returns>
    </member>
    <member name="M:Llvm.NET.DataLayout.PointerSize(System.UInt32)">
      <summary>Retrieves the size of a pointer for a given address space of the target</summary>
      <param name="addressSpace">Address space for the pointer</param>
      <returns>Size of a pointer</returns>
    </member>
    <member name="M:Llvm.NET.DataLayout.PreferredAlignmentOf(Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.DataLayout.PreferredAlignmentOf(Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.DataLayout.PreferredBitAlignementOf(Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.DataLayout.StoreSizeOf(Llvm.NET.Types.ITypeRef)">
      <summary>Retrieves the number of bits required to store a value of the given type</summary>
      <param name="typeRef">Type to retrieve the storage size of</param>
      <returns>Number of bits required to store a value of the given type in the target</returns>
    </member>
    <member name="M:Llvm.NET.DataLayout.ToString"></member>
    <member name="T:Llvm.NET.ExtensiblePropertyContainer">
      <summary>Common implementation of <see cref="T:Llvm.NET.IExtensiblePropertyContainer" /></summary>
    </member>
    <member name="M:Llvm.NET.ExtensiblePropertyContainer.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.ExtensiblePropertyContainer</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.ExtensiblePropertyContainer.AddExtendedPropertyValue(System.String,System.Object)">
      <summary>Adds a value to the container</summary>
      <param name="id">Id of the value</param>
      <param name="value">value to add</param>
    </member>
    <member name="M:Llvm.NET.ExtensiblePropertyContainer.TryGetExtendedPropertyValue``1(System.String,``0@)">
      <summary>Try to get a value from the container</summary>
      <param name="id">id of the value to retrieve</param>
      <param name="value">value retrieved if present (or default value of type <typeparamref name="T" /> otherwise)</param>
      <typeparam name="T">Type of value to retrieve</typeparam>
      <returns>
            true if the item was found and it's type matches <typeparamref name="T" /> false otherwise.
            </returns>
    </member>
    <member name="T:Llvm.NET.ExtensiblePropertyDescriptor`1">
      <summary>Provides consistent accessors for an extended property</summary>
      <typeparam name="T">Type of values stored in the property</typeparam>
    </member>
    <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.#ctor(System.String)">
      <summary>Creates a new instance of a property descriptor</summary>
      <param name="name">Name of the extended property</param>
    </member>
    <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.GetValueFrom(Llvm.NET.IExtensiblePropertyContainer)">
      <summary>Gets a value for the property from the container</summary>
      <param name="container">container</param>
      <returns>Value retrieved from the property or the default value of type <typeparamref name="T" /></returns>
    </member>
    <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.GetValueFrom(Llvm.NET.IExtensiblePropertyContainer,System.Func{`0})">
      <summary>Gets a value for the property from the container</summary>
      <param name="container">container</param>
      <param name="lazyDefaultFactory">default value factory delegate to create the default value if the value is not yet present as an extended property</param>
      <returns>Value retrieved from the property or default value created by <paramref name="lazyDefaultFactory" /> if it wasn't found</returns>
    </member>
    <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.GetValueFrom(Llvm.NET.IExtensiblePropertyContainer,`0)">
      <summary>Gets a value for the property from the container</summary>
      <param name="container">container</param>
      <param name="defaultValue">default value if the value is not yet present as an extended property</param>
      <returns>Value retrieved from the property or <paramref name="defaultValue" /> if it wasn't found</returns>
    </member>
    <member name="P:Llvm.NET.ExtensiblePropertyDescriptor`1.Name">
      <summary>Name of the property</summary>
    </member>
    <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.SetValueIn(Llvm.NET.IExtensiblePropertyContainer,`0)">
      <summary>Sets the value of an extended property in a container</summary>
      <param name="container">Container to set the value in</param>
      <param name="value">value of the property</param>
    </member>
    <member name="T:Llvm.NET.FunctionAttributeIndex">
      <summary>Function index for attributes</summary>
    </member>
    <member name="F:Llvm.NET.FunctionAttributeIndex.Function">
      <summary>The attribute applies to the function itself</summary>
    </member>
    <member name="F:Llvm.NET.FunctionAttributeIndex.ReturnType">
      <summary>The attribute applies to the return type of the function</summary>
    </member>
    <member name="F:Llvm.NET.FunctionAttributeIndex.Parameter0">
      <summary>The attribute applies to the first parameter of the function</summary>
    </member>
    <member name="T:Llvm.NET.IExtensiblePropertyContainer">
      <summary>Interface to allow adding arbitrary named data items to an object</summary>
    </member>
    <member name="M:Llvm.NET.IExtensiblePropertyContainer.AddExtendedPropertyValue(System.String,System.Object)">
      <summary>Adds a value to the container</summary>
      <param name="id">Id of the value</param>
      <param name="value">value to add</param>
    </member>
    <member name="M:Llvm.NET.IExtensiblePropertyContainer.TryGetExtendedPropertyValue``1(System.String,``0@)">
      <summary>Try to get a value from the container</summary>
      <param name="id">id of the value to retrieve</param>
      <param name="value">value retrieved if present (or default value of type <typeparamref name="T" /> otherwise)</param>
      <typeparam name="T">Type of value to retrieve</typeparam>
      <returns>
            true if the item was found and it's type matches <typeparamref name="T" /> false otherwise.
            </returns>
    </member>
    <member name="T:Llvm.NET.InternalCodeGeneratorException">
      <summary>Exception generated when the internal state of the code generation cannot proceed due to an internal error</summary>
    </member>
    <member name="M:Llvm.NET.InternalCodeGeneratorException.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.InternalCodeGeneratorException</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.InternalCodeGeneratorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.InternalCodeGeneratorException</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.InternalCodeGeneratorException.#ctor(System.String)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.InternalCodeGeneratorException</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.InternalCodeGeneratorException.#ctor(System.String,System.Exception)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.InternalCodeGeneratorException</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="T:Llvm.NET.IntPredicate">
      <summary>Predicate enumeration for integer comparison</summary>
    </member>
    <member name="T:Llvm.NET.Linkage">
      <summary>Linkage specification for functions and globals</summary>
    </member>
    <member name="T:Llvm.NET.LlvmMetadata">
      <summary>Root of the LLVM Metadata hierarchy</summary>
    </member>
    <member name="M:Llvm.NET.LlvmMetadata.ReplaceAllUsesWith(Llvm.NET.LlvmMetadata)">
      <summary>Replace all uses of this descriptor with another</summary>
      <param name="other">New descriptor to replace this one with</param>
    </member>
    <member name="M:Llvm.NET.LlvmMetadata.ToString">
      <summary>Returns a string that represents the current object.</summary>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="T:Llvm.NET.LocalAsMetadata"></member>
    <member name="T:Llvm.NET.MDNode"></member>
    <member name="P:Llvm.NET.MDNode.Context"></member>
    <member name="P:Llvm.NET.MDNode.IsDeleted"></member>
    <member name="P:Llvm.NET.MDNode.IsDistinct"></member>
    <member name="P:Llvm.NET.MDNode.IsResolved"></member>
    <member name="P:Llvm.NET.MDNode.IsTemporary"></member>
    <member name="P:Llvm.NET.MDNode.IsUniqued"></member>
    <member name="P:Llvm.NET.MDNode.Operands"></member>
    <member name="M:Llvm.NET.MDNode.ReplaceAllUsesWith(Llvm.NET.LlvmMetadata)"></member>
    <member name="M:Llvm.NET.MDNode.ResolveCycles"></member>
    <member name="T:Llvm.NET.MDOperand"></member>
    <member name="P:Llvm.NET.MDOperand.Metadata"></member>
    <member name="P:Llvm.NET.MDOperand.OwningNode"></member>
    <member name="T:Llvm.NET.MDString"></member>
    <member name="M:Llvm.NET.MDString.ToString"></member>
    <member name="T:Llvm.NET.MDTuple"></member>
    <member name="T:Llvm.NET.MemoryBuffer">
      <summary>LLVM MemoryBuffer</summary>
    </member>
    <member name="M:Llvm.NET.MemoryBuffer.#ctor(System.String)">
      <summary>Load a file as an LLVM Memory Buffer</summary>
      <param name="path">Path of the file to load into a <see cref="T:Llvm.NET.MemoryBuffer" /></param>
    </member>
    <member name="M:Llvm.NET.MemoryBuffer.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.MemoryBuffer</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Llvm.NET.MemoryBuffer.Size">
      <summary>Size of the buffer</summary>
    </member>
    <member name="T:Llvm.NET.MetadataAsValue"></member>
    <member name="T:Llvm.NET.ModuleFlagBehavior">
      <summary>Enumeration to indicate the behavior of module level flags metadata sharing the same name in a <see cref="T:Llvm.NET.NativeModule" /></summary>
    </member>
    <member name="F:Llvm.NET.ModuleFlagBehavior.Invalid">
      <summary>Invalid value (default value for this enumeration)</summary>
    </member>
    <member name="F:Llvm.NET.ModuleFlagBehavior.Error">
      <summary>Emits an error if two values disagree, otherwise the resulting value is that of the operands</summary>
    </member>
    <member name="F:Llvm.NET.ModuleFlagBehavior.Warning">
      <summary>Emits a warning if two values disagree. The result will be the operand for the flag from the first module being linked</summary>
    </member>
    <member name="F:Llvm.NET.ModuleFlagBehavior.Require">
      <summary>Adds a requirement that another module flag be present and have a specified value after linking is performed</summary>
    </member>
    <member name="F:Llvm.NET.ModuleFlagBehavior.Override">
      <summary>Uses the specified value, regardless of the behavior or value of the other module</summary>
    </member>
    <member name="F:Llvm.NET.ModuleFlagBehavior.Append">
      <summary>Appends the two values, which are required to be metadata nodes</summary>
    </member>
    <member name="F:Llvm.NET.ModuleFlagBehavior.AppendUnique">
      <summary>Appends the two values, which are required to be metadata nodes dropping duplicate entries in the second list</summary>
    </member>
    <member name="T:Llvm.NET.NamedMDNode">
      <summary>Wraps an LLVM NamedMDNode</summary>
    </member>
    <member name="P:Llvm.NET.NamedMDNode.Operands"></member>
    <member name="P:Llvm.NET.NamedMDNode.ParentModule"></member>
    <member name="T:Llvm.NET.NativeModule">
      <summary>LLVM Bit code module</summary>
    </member>
    <member name="M:Llvm.NET.NativeModule.#ctor">
      <summary>Creates an unnamed module without debug information</summary>
    </member>
    <member name="M:Llvm.NET.NativeModule.#ctor(System.String)">
      <summary>Creates a new module with the specified id in a new context</summary>
      <param name="moduleId">Module's ID</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.#ctor(System.String,Llvm.NET.Context)">
      <summary>Creates an named module in a given context</summary>
      <param name="moduleId">Module's ID</param>
      <param name="context">Context for the module</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.#ctor(System.String,Llvm.NET.Context,Llvm.NET.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
      <summary>Creates a named module with a root <see cref="P:Llvm.NET.NativeModule.DICompileUnit" /> to contain debugging information</summary>
      <param name="moduleId">Module name</param>
      <param name="context">Context for the module</param>
      <param name="language">Language to store in the debugging information</param>
      <param name="srcFilePath">path of source file to set for the compilation unit</param>
      <param name="producer">Name of the application producing this module</param>
      <param name="optimized">Flag to indicate if the module is optimized</param>
      <param name="compilationFlags">Additional flags</param>
      <param name="runtimeVersion">Runtime version if any (use 0 if the runtime version has no meaning)</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.#ctor(System.String,Llvm.NET.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
      <summary>Creates a named module with a root <see cref="P:Llvm.NET.NativeModule.DICompileUnit" /> to contain debugging information</summary>
      <param name="moduleId">Module name</param>
      <param name="language">Language to store in the debugging information</param>
      <param name="srcFilePath">path of source file to set for the compilation unit</param>
      <param name="producer">Name of the application producing this module</param>
      <param name="optimized">Flag to indicate if the module is optimized</param>
      <param name="flags">Additional flags</param>
      <param name="runtimeVersion">Runtime version if any (use 0 if the runtime version has no meaning)</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddAlias(Llvm.NET.Values.Value,System.String)">
      <summary>Add an alias to the module</summary>
      <param name="aliasee">Value being aliased</param>
      <param name="aliasName">Name of the alias</param>
      <returns>
        <see cref="T:Llvm.NET.Values.GlobalAlias" /> for the alias</returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddFunction(System.String,Llvm.NET.Types.IFunctionType)">
      <summary>Add a function with the specified signature to the module</summary>
      <param name="name">Name of the function to add</param>
      <param name="signature">Signature of the function</param>
      <returns>
        <see cref="T:Llvm.NET.Values.Function" />matching the specified signature and name</returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddGlobal(Llvm.NET.Types.ITypeRef,System.Boolean,Llvm.NET.Linkage,Llvm.NET.Values.Constant)">
      <summary>Adds a global to this module</summary>
      <param name="typeRef">Type of the global's value</param>
      <param name="isConst">Flag to indicate if this global is a constant</param>
      <param name="linkage">Linkage type for this global</param>
      <param name="constVal">Initial value for the global</param>
      <returns>New global variable</returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddGlobal(Llvm.NET.Types.ITypeRef,System.Boolean,Llvm.NET.Linkage,Llvm.NET.Values.Constant,System.String)">
      <summary>Adds a global to this module</summary>
      <param name="typeRef">Type of the global's value</param>
      <param name="isConst">Flag to indicate if this global is a constant</param>
      <param name="linkage">Linkage type for this global</param>
      <param name="constVal">Initial value for the global</param>
      <param name="name">Name of the variable</param>
      <returns>New global variable</returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddGlobal(Llvm.NET.Types.ITypeRef,System.String)">
      <summary>Adds a global to this module</summary>
      <param name="typeRef">Type of the global's value</param>
      <param name="name">Name of the global</param>
      <returns>The new <see cref="T:Llvm.NET.Values.GlobalVariable" /></returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddModuleFlag(Llvm.NET.ModuleFlagBehavior,System.String,Llvm.NET.LlvmMetadata)">
      <summary>Adds a module flag to the module</summary>
      <param name="behavior">Module flag behavior for this flag</param>
      <param name="name">Name of the flag</param>
      <param name="value">Value of the flag</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddModuleFlag(Llvm.NET.ModuleFlagBehavior,System.String,System.UInt32)">
      <summary>Adds a module flag to the module</summary>
      <param name="behavior">Module flag behavior for this flag</param>
      <param name="name">Name of the flag</param>
      <param name="value">Value of the flag</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddNamedMetadataOperand(System.String,Llvm.NET.LlvmMetadata)">
      <summary>Adds operand value to named metadata</summary>
      <param name="name">Name of the metadata</param>
      <param name="value">operand value</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.AddVersionIdentMetadata(System.String)">
      <summary>Adds an llvm.ident metadata string to the module</summary>
      <param name="version">version information to place in the llvm.ident metadata</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.AsString">
      <summary>Creates a string representation of the module</summary>
      <returns>LLVM textual representation of the module</returns>
    </member>
    <member name="P:Llvm.NET.NativeModule.Context">
      <summary>
        <see cref="P:Llvm.NET.NativeModule.Context" /> this module belongs to</summary>
    </member>
    <member name="M:Llvm.NET.NativeModule.CreateFunction(Llvm.NET.DebugInfo.DIScope,System.String,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DebugFunctionType,System.Boolean,System.Boolean,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Boolean,Llvm.NET.MDNode,Llvm.NET.MDNode)">
      <summary>Creates a Function definition with Debug information</summary>
      <param name="scope">Containing scope for the function</param>
      <param name="name">Name of the function in source language form</param>
      <param name="linkageName">Mangled linker visible name of the function (may be same as <paramref name="name" /> if mangling not required by source language</param>
      <param name="file">File containing the function definition</param>
      <param name="line">Line number of the function definition</param>
      <param name="signature">LLVM Function type for the signature of the function</param>
      <param name="isLocalToUnit">Flag to indicate if this function is local to the compilation unit</param>
      <param name="isDefinition">Flag to indicate if this is a definition</param>
      <param name="scopeLine">First line of the function's outermost scope, this may not be the same as the first line of the function definition due to source formatting</param>
      <param name="debugFlags">Additional flags describing this function</param>
      <param name="isOptimized">Flag to indicate if this function is optimized</param>
      <param name="tParam"></param>
      <param name="decl"></param>
      <returns>Function described by the arguments</returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.CreateFunction(System.String,System.Boolean,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}[])"></member>
    <member name="M:Llvm.NET.NativeModule.CreateMDNode(System.String)">
      <summary>Create an <see cref="T:Llvm.NET.MDNode" /> from a string</summary>
      <param name="value">String value</param>
      <returns>New node with the string as <see cref="P:Llvm.NET.MDNode.Operands" />[0] (as an MDString)</returns>
    </member>
    <member name="P:Llvm.NET.NativeModule.DataLayoutString">
      <summary>Data layout string</summary>
    </member>
    <member name="F:Llvm.NET.NativeModule.DebugMetadataVersion">
      <summary>Version of the Debug information Metadata</summary>
    </member>
    <member name="F:Llvm.NET.NativeModule.DebugVersionValue">
      <summary>Name of the Debug Version information module flag</summary>
    </member>
    <member name="P:Llvm.NET.NativeModule.DIBuilder">
      <summary>
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder" /> to create debug information for this module</summary>
    </member>
    <member name="P:Llvm.NET.NativeModule.DICompileUnit">
      <summary>Debug Compile unit for this module</summary>
    </member>
    <member name="M:Llvm.NET.NativeModule.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.NativeModule</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="F:Llvm.NET.NativeModule.DwarfVersionValue">
      <summary>Name of the Dwarf Version module flag</summary>
    </member>
    <member name="M:Llvm.NET.NativeModule.Finalize"></member>
    <member name="P:Llvm.NET.NativeModule.Functions">
      <summary>Enumerable collection of functions contained in this module</summary>
    </member>
    <member name="M:Llvm.NET.NativeModule.GetAlias(System.String)">
      <summary>Get an alias by name</summary>
      <param name="name">name of the alias to get</param>
      <returns>Alias matching <paramref name="name" /> or null if no such alias exists</returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.GetFunction(System.String)">
      <summary>Gets a function by name from this module</summary>
      <param name="name">Name of the function to get</param>
      <returns>The function or null if not found</returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.GetNamedGlobal(System.String)">
      <summary>Retrieves a named global from the module</summary>
      <param name="name"></param>
      <returns></returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.GetTypeByName(System.String)">
      <summary>Retrieves a <see cref="T:Llvm.NET.Types.ITypeRef" /> by name from the module</summary>
      <param name="name">Name of the type</param>
      <returns>The type or null if no type with the specified name exists in the module</returns>
    </member>
    <member name="P:Llvm.NET.NativeModule.Globals">
      <summary>Globals contained by this module</summary>
    </member>
    <member name="P:Llvm.NET.NativeModule.Layout">
      <summary>Target data layout for this module</summary>
    </member>
    <member name="M:Llvm.NET.NativeModule.Link(Llvm.NET.NativeModule)"></member>
    <member name="M:Llvm.NET.NativeModule.Llvm#NET#IExtensiblePropertyContainer#AddExtendedPropertyValue(System.String,System.Object)">
      <summary>Adds a value to the container</summary>
      <param name="id">Id of the value</param>
      <param name="value">value to add</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.Llvm#NET#IExtensiblePropertyContainer#TryGetExtendedPropertyValue``1(System.String,``0@)">
      <summary>Try to get a value from the container</summary>
      <param name="id">id of the value to retrieve</param>
      <param name="value">value retrieved if present (or default value of type <typeparamref name="T" /> otherwise)</param>
      <typeparam name="T">Type of value to retrieve</typeparam>
      <returns>
            true if the item was found and it's type matches <typeparamref name="T" /> false otherwise.
            </returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.LoadFrom(System.String,Llvm.NET.Context)">
      <summary>Load a bit-code module from a given file</summary>
      <param name="path">path of the file to load</param>
      <param name="context">Context to use for creating the module</param>
      <returns>Loaded <see cref="T:Llvm.NET.NativeModule" /></returns>
    </member>
    <member name="P:Llvm.NET.NativeModule.ModuleFlags"></member>
    <member name="P:Llvm.NET.NativeModule.Name">
      <summary>Name of the module</summary>
    </member>
    <member name="P:Llvm.NET.NativeModule.TargetTriple">
      <summary>Target Triple describing the target, ABI and OS</summary>
    </member>
    <member name="M:Llvm.NET.NativeModule.Verify(System.String@)">
      <summary>Verifies a bit-code module</summary>
      <param name="errmsg">Error messages describing any issues found in the bit-code</param>
      <returns>true if the verification succeeded and false if not.</returns>
    </member>
    <member name="M:Llvm.NET.NativeModule.WriteToFile(System.String)">
      <summary>Writes a bit-code module to a file</summary>
      <param name="path">Path to write the bit-code into</param>
    </member>
    <member name="M:Llvm.NET.NativeModule.WriteToTextFile(System.String,System.String@)">
      <summary>Writes this module as LLVM IR source to a file</summary>
      <param name="path">File to write the LLVM IR source to</param>
      <param name="errMsg">Error messages encountered, if any</param>
      <returns>
        <see langword="true" /> if successful or <see langword="false" /> if not</returns>
    </member>
    <member name="T:Llvm.NET.OpCode">
      <summary>LLVM Instruction opcodes</summary>
    </member>
    <member name="T:Llvm.NET.PassManagerBuilder">
      <summary>Provides a wrapper around an LLVM Pass Manager</summary>
    </member>
    <member name="M:Llvm.NET.PassManagerBuilder.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.PassManagerBuilder</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.PassManagerBuilder.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.PassManagerBuilder</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.PassManagerBuilder.SetDisableSimplifyLibCalls(System.Boolean)"></member>
    <member name="M:Llvm.NET.PassManagerBuilder.SetDisableUnitAtATime(System.Boolean)"></member>
    <member name="M:Llvm.NET.PassManagerBuilder.SetDisableUnrollLoops(System.Boolean)"></member>
    <member name="M:Llvm.NET.PassManagerBuilder.SetOptLevel(System.UInt32)"></member>
    <member name="M:Llvm.NET.PassManagerBuilder.SetSizeLevel(System.UInt32)"></member>
    <member name="T:Llvm.NET.PassRegistry"></member>
    <member name="M:Llvm.NET.PassRegistry.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.PassRegistry</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.PassRegistry.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.PassRegistry</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.PassRegistry.Finalize"></member>
    <member name="P:Llvm.NET.PassRegistry.GlobalRegistry"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeAll"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeAnalysis"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeCodeGen"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeCore"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeInstCombine"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeInstrumentation"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeIPA"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeIPO"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeObjCARCOpts"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeScalarOpts"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeTarget"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeTransformUtils"></member>
    <member name="M:Llvm.NET.PassRegistry.InitializeVectorization"></member>
    <member name="T:Llvm.NET.Predicate">
      <summary>Unified predicate enumeration</summary>
    </member>
    <member name="F:Llvm.NET.Predicate.BadFcmpPredicate">
      <summary>Any value Greater than or equal to this is not valid for Fcmp operations</summary>
    </member>
    <member name="F:Llvm.NET.Predicate.BadIcmpPredicate">
      <summary>Any value Greater than or equal to this is not valid for Icmp operations</summary>
    </member>
    <member name="T:Llvm.NET.RealPredicate">
      <summary>Predicate enumeration for integer comparison</summary>
    </member>
    <member name="T:Llvm.NET.Reloc">
      <summary>Relocation type for target code generation</summary>
    </member>
    <member name="T:Llvm.NET.ScalarEnumerable">
      <summary>Static utility class for constructing enumerable sequences using single values</summary>
    </member>
    <member name="M:Llvm.NET.ScalarEnumerable.Combine``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>Creates a new enumerable that appends a value to an existing enumerable sequence</summary>
      <param name="values">Existing enumerable</param>
      <param name="scalar">Value to append to the existing sequence</param>
      <typeparam name="T">Type of values to enumerate</typeparam>
      <returns>New enumerable sequence ending with <paramref name="scalar" /></returns>
    </member>
    <member name="M:Llvm.NET.ScalarEnumerable.Combine``1(``0,System.Collections.Generic.IEnumerable{``0})">
      <summary>Creates a new enumerable that prepends a value to an existing enumerable sequence</summary>
      <param name="scalar">Value to prepend to the sequence</param>
      <param name="values">Existing enumerable</param>
      <typeparam name="T">Type of values to enumerate</typeparam>
      <returns>New enumerable sequence starting with <paramref name="scalar" /></returns>
    </member>
    <member name="M:Llvm.NET.ScalarEnumerable.From``1(``0)">
      <summary>Create an enumerator that provides a single value</summary>
      <param name="scalar">Value for the enumerator to provide</param>
      <typeparam name="T">Type of value to enumerate</typeparam>
      <returns>Enumerable sequence containing a single value</returns>
    </member>
    <member name="T:Llvm.NET.StaticState">
      <summary>Provides support for various LLVM static state initialization and manipulation</summary>
    </member>
    <member name="M:Llvm.NET.StaticState.ParseCommandLineOptions(System.String[],System.String)"></member>
    <member name="M:Llvm.NET.StaticState.RegisterAArch64(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for ARM AArch64 target(s)</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterAll(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for all available targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterAMDGPU(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for AMDGPU targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterARM(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for ARM 32bit and 16bit thumb targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterHexagon(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for the Hexagon CPU</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterMips(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for MIPS targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterMSP430(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for MSP430 targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterNative(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for the target representing the system the calling process is running on</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterNVPTX(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for the NVPTX targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterPowerPC(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for the PowerPC targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterSparc(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for SPARC targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterSystemZ(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for SystemZ targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterX86(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for X86 targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="M:Llvm.NET.StaticState.RegisterXCore(Llvm.NET.TargetRegistrations)">
      <summary>Registers components for XCore targets</summary>
      <param name="registrations">Flags indicating which components to register/enable</param>
    </member>
    <member name="T:Llvm.NET.Target">
      <summary>LLVM Target Instruction Set Architecture</summary>
    </member>
    <member name="P:Llvm.NET.Target.AvailableTargets">
      <summary>Retrieves an enumerable collection of the available targets built into this library</summary>
    </member>
    <member name="M:Llvm.NET.Target.CreateTargetMachine(Llvm.NET.Context,System.String,System.String,System.String,Llvm.NET.CodeGenOpt,Llvm.NET.Reloc,Llvm.NET.CodeModel)">
      <summary>Creates a <see cref="T:Llvm.NET.TargetMachine" /> for the target and specified parameters</summary>
      <param name="context">Context to use for LLVM objects created by this machine</param>
      <param name="triple">Target triple for this machine (e.g. -mtriple)</param>
      <param name="cpu">CPU for this machine (e.g. -mcpu)</param>
      <param name="features">Features for this machine (e.g. -mattr...)</param>
      <param name="optLevel">Optimization level</param>
      <param name="relocationMode">Relocation mode for generated code</param>
      <param name="codeModel">
        <see cref="T:Llvm.NET.CodeModel" /> to use for generated code</param>
      <returns>
        <see cref="T:Llvm.NET.TargetMachine" /> based on the specified parameters</returns>
    </member>
    <member name="P:Llvm.NET.Target.Description">
      <summary>Description of this target</summary>
    </member>
    <member name="M:Llvm.NET.Target.FromTriple(System.String)">
      <summary>Gets the target for a given target "triple" value</summary>
      <param name="targetTriple">Target triple string describing the target</param>
      <returns>Target for the given triple</returns>
    </member>
    <member name="P:Llvm.NET.Target.HasAsmBackEnd">
      <summary>Flag indicating if this target has an Assembly code generating back end initialized</summary>
    </member>
    <member name="P:Llvm.NET.Target.HasJIT">
      <summary>Flag indicating if this target has JIT support</summary>
    </member>
    <member name="P:Llvm.NET.Target.HasTargetMachine">
      <summary>Flag indicating if this target has a TargetMachine initialized</summary>
    </member>
    <member name="F:Llvm.NET.Target.MsVCWin32AbiTriple"></member>
    <member name="P:Llvm.NET.Target.Name">
      <summary>Name of this target</summary>
    </member>
    <member name="F:Llvm.NET.Target.ThumbV7mEabiTriple"></member>
    <member name="F:Llvm.NET.Target.UnknownEabiTriple"></member>
    <member name="T:Llvm.NET.TargetMachine">
      <summary>Target specific code generation information</summary>
    </member>
    <member name="P:Llvm.NET.TargetMachine.Context">
      <summary>
        <see cref="P:Llvm.NET.TargetMachine.Context" />This machine is associated with</summary>
    </member>
    <member name="P:Llvm.NET.TargetMachine.Cpu">
      <summary>CPU Type for this machine</summary>
    </member>
    <member name="M:Llvm.NET.TargetMachine.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.TargetMachine</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.TargetMachine.Dispose(System.Boolean)">
      <summary>
        <markup>
          <include item="SMCAutoDocDisposeBool">
            <parameter>Llvm.NET.TargetMachine</parameter>
          </include>
        </markup>
      </summary>
      <param name="disposing">
        <markup>
          <include item="SMCAutoDocDisposeParam">
            <parameter>Llvm.NET.TargetMachine</parameter>
          </include>
        </markup>
      </param>
    </member>
    <member name="M:Llvm.NET.TargetMachine.EmitToFile(Llvm.NET.NativeModule,System.String,Llvm.NET.CodeGenFileType)">
      <summary>Generate code for the target machine from a module</summary>
      <param name="module">
        <see cref="T:Llvm.NET.NativeModule" /> to generate the code from</param>
      <param name="path">Path to the output file</param>
      <param name="fileType">Type of file to emit</param>
    </member>
    <member name="P:Llvm.NET.TargetMachine.Features">
      <summary>CPU specific features for this machine</summary>
    </member>
    <member name="M:Llvm.NET.TargetMachine.Finalize"></member>
    <member name="P:Llvm.NET.TargetMachine.Target">
      <summary>Retrieves the Target that owns this <see cref="T:Llvm.NET.TargetMachine" /></summary>
    </member>
    <member name="P:Llvm.NET.TargetMachine.TargetData">
      <summary>Gets Layout information for this machine</summary>
    </member>
    <member name="P:Llvm.NET.TargetMachine.Triple">
      <summary>Target triple describing this machine</summary>
    </member>
    <member name="T:Llvm.NET.TargetRegistrations">
      <summary>Target tools to register/enable</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.None">
      <summary>Register nothing</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.Target">
      <summary>Register the Target class</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.TargetInfo">
      <summary>Register the Target info for the target</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.TargetMachine">
      <summary>Register the target machine(s) for a target</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.AsmPrinter">
      <summary>Registers the assembly source code generator for a target</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.Disassembler">
      <summary>Registers the Disassembler for a target</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.AsmParser">
      <summary>Registers the assembly source parser for a target</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.CodeGen">
      <summary>Registers all the code generation components</summary>
    </member>
    <member name="F:Llvm.NET.TargetRegistrations.All">
      <summary>Registers all components</summary>
    </member>
    <member name="T:Llvm.NET.TypeKind">
      <summary>Basic kind of a type</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Void">
      <summary>Type with no size</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Float16">
      <summary>16 bit floating point type</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Float32">
      <summary>32 bit floating point type</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Float64">
      <summary>64 bit floating point type</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.X86Float80">
      <summary>80 bit floating point type (X87)</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Float128m112">
      <summary>128 bit floating point type (112-bit mantissa)</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Float128">
      <summary>128 bit floating point type (two 64-bits)</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Label">
      <summary>
        <see cref="T:Llvm.NET.Values.BasicBlock" /> instruction label</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Integer">
      <summary>Arbitrary bit width integers</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Function">
      <summary>
        <see cref="T:Llvm.NET.Types.IFunctionType" />
      </summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Struct">
      <summary>
        <see cref="T:Llvm.NET.Types.IStructType" />
      </summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Array">
      <summary>
        <see cref="T:Llvm.NET.Types.IArrayType" />
      </summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Pointer">
      <summary>
        <see cref="T:Llvm.NET.Types.IPointerType" />
      </summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Vector">
      <summary>SIMD 'packed' format, or other <see cref="T:Llvm.NET.Types.IVectorType" /> implementation</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Metadata">
      <summary>
        <see cref="T:Llvm.NET.LlvmMetadata" />
      </summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.X86MMX">
      <summary>x86 MMX data type</summary>
    </member>
    <member name="F:Llvm.NET.TypeKind.Token">
      <summary>Exception handler token</summary>
    </member>
    <member name="T:Llvm.NET.ValueAsMetadata"></member>
    <member name="T:Llvm.NET.Visibility">
      <summary>Enumeration for the visibility of a global value</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugArrayType">
      <summary>Provides debug information binding between an <see cref="T:Llvm.NET.Types.IArrayType" />and a <see cref="T:Llvm.NET.DebugInfo.DICompositeType" /></summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugArrayType.#ctor(Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.NativeModule,System.UInt32,System.UInt32)">
      <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugArrayType" /></summary>
      <param name="elementType">Type of elements in the array</param>
      <param name="module">
        <see cref="T:Llvm.NET.NativeModule" /> to use for the context of the debug information</param>
      <param name="count">Number of elements in the array</param>
      <param name="lowerBound">
        <see cref="P:Llvm.NET.DebugInfo.DebugArrayType.LowerBound" /> value for the array indices [Default: 0]</param>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugArrayType.#ctor(Llvm.NET.Types.IArrayType,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.NativeModule,System.UInt32,System.UInt32)">
      <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DebugArrayType" /></summary>
      <param name="llvmType">Underlying LLVM array type to bind debug info to</param>
      <param name="elementType">Array element type with debug information</param>
      <param name="module">module to use for creating debug information</param>
      <param name="count">Number of elements in the array</param>
      <param name="lowerBound">Lower bound of the array [default = 0]</param>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugArrayType.#ctor(Llvm.NET.Types.IArrayType,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIType,System.UInt32,System.UInt32)">
      <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugArrayType" /></summary>
      <param name="llvmType">Native LLVM type for the elements</param>
      <param name="module">
        <see cref="T:Llvm.NET.NativeModule" /> to use for the context of the debug information</param>
      <param name="elementType">Debug type of the array elements</param>
      <param name="count">Number of elements in the array</param>
      <param name="lowerBound">
        <see cref="P:Llvm.NET.DebugInfo.DebugArrayType.LowerBound" /> value for the array indices [Default: 0]</param>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugArrayType.DebugElementType">
      <summary>Full <see cref="T:Llvm.NET.DebugInfo.IDebugType`2" /> type for the elements</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugArrayType.ElementType">
      <summary>Type of elements in the sequence</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugArrayType.Length">
      <summary>Length of the array</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugArrayType.LowerBound">
      <summary>Lower bound of the array, usually but not always zero</summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugArrayType.ResolveTemporary(Llvm.NET.DataLayout,Llvm.NET.DebugInfo.DebugInfoBuilder)">
      <summary>Resolves a temporary metadata node for the array if full size information wasn't available at creation time</summary>
      <param name="layout">Type layout information</param>
      <param name="diBuilder">Debug information builder for creating the new debug information</param>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugBasicType">
      <summary>Debug information binding between an LLVM native <see cref="T:Llvm.NET.Types.ITypeRef" /> and a <see cref="T:Llvm.NET.DebugInfo.DIBasicType" /></summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugBasicType.#ctor(Llvm.NET.Types.ITypeRef,Llvm.NET.NativeModule,System.String,Llvm.NET.DebugInfo.DiTypeKind)">
      <summary>Create a debug type for a basic type</summary>
      <param name="llvmType">Type to wrap debug information for</param>
      <param name="module">Module to use when constructing the debug information</param>
      <param name="name">Source language name of the type</param>
      <param name="encoding">Encoding for the type</param>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugFunctionType">
      <summary>This class provides debug information binding for an <see cref="T:Llvm.NET.Types.IFunctionType" />
            and a <see cref="T:Llvm.NET.DebugInfo.DISubroutineType" /></summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugFunctionType.#ctor(Llvm.NET.Types.IFunctionType,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DebugInfoFlags,Llvm.NET.DebugInfo.DebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.DebugInfo.DebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}[])">
      <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugFunctionType" /></summary>
      <param name="llvmType">Native LLVM function signature</param>
      <param name="module">
        <see cref="T:Llvm.NET.NativeModule" /> to use when construction debug information</param>
      <param name="debugFlags">
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoFlags" /> for this signature</param>
      <param name="retType">Return type for the function</param>
      <param name="argTypes">Potentially empty set of argument types for the signature</param>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugFunctionType.IsVarArg">
      <summary>Flag to indicate if this signature is for a variadic function</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugFunctionType.ParameterTypes">
      <summary>Collection of types of the parameters for the function</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugFunctionType.ReturnType">
      <summary>Return type of the function</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugInfoBuilder">
      <summary>DebugInfoBuilder is a factory class for creating DebugInformation for an LLVM
            <see cref="T:Llvm.NET.NativeModule" /></summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateArgument(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DIType,System.Boolean,Llvm.NET.DebugInfo.DebugInfoFlags,System.UInt16)">
      <summary>Creates an argument for a function as a <see cref="T:Llvm.NET.DebugInfo.DILocalVariable" /></summary>
      <param name="scope">Scope for the argument</param>
      <param name="name">Name of the argument</param>
      <param name="file">
        <see cref="T:Llvm.NET.DebugInfo.DIFile" /> containing the function this argument is declared in</param>
      <param name="line">Line number fort his argument</param>
      <param name="type">Debug type for this argument</param>
      <param name="alwaysPreserve">Flag to indicate if this argument is always preserved for debug view even if optimization would remove it</param>
      <param name="debugFlags">
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoFlags" /> for this argument</param>
      <param name="argNo">One based argument index on the method (e.g the first argument is 1 not 0 )</param>
      <returns>
        <see cref="T:Llvm.NET.DebugInfo.DILocalVariable" /> representing the function argument</returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateArrayType(System.UInt64,System.UInt64,Llvm.NET.DebugInfo.DIType,Llvm.NET.DebugInfo.DINode[])"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateArrayType(System.UInt64,System.UInt64,Llvm.NET.DebugInfo.DIType,Llvm.NET.DebugInfo.DINodeArray)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateBasicType(System.String,System.UInt64,System.UInt64,Llvm.NET.DebugInfo.DiTypeKind)">
      <summary>Construct debug information for a basic type (a.k.a. primitive type)</summary>
      <param name="name">Name of the type</param>
      <param name="bitSize">Bit size for the type</param>
      <param name="bitAlign">Bit alignment for the type</param>
      <param name="encoding">
        <see cref="T:Llvm.NET.DebugInfo.DiTypeKind" /> encoding for the type</param>
      <returns></returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateCompileUnit(Llvm.NET.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
      <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DICompileUnit" /></summary>
      <param name="language">
        <see cref="T:Llvm.NET.DebugInfo.SourceLanguage" /> for the compilation unit</param>
      <param name="sourceFilePath">Full path to the source file of this compilation unit</param>
      <param name="producer">Name of the application processing the compilation unit</param>
      <param name="optimized">Flag to indicate if the code in this compilation unit is optimized</param>
      <param name="compilationFlags">Additional tool specific flags</param>
      <param name="runtimeVersion">Runtime version</param>
      <returns>
        <see cref="T:Llvm.NET.DebugInfo.DICompileUnit" />
      </returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateCompileUnit(Llvm.NET.DebugInfo.SourceLanguage,System.String,System.String,System.String,System.Boolean,System.String,System.UInt32)">
      <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DICompileUnit" /></summary>
      <param name="language">
        <see cref="T:Llvm.NET.DebugInfo.SourceLanguage" /> for the compilation unit</param>
      <param name="fileName">Name of the source file of this compilation unit (without any path)</param>
      <param name="fileDirectory">Path of the directory containing the file</param>
      <param name="producer">Name of the application processing the compilation unit</param>
      <param name="optimized">Flag to indicate if the code in this compilation unit is optimized</param>
      <param name="compilationFlags">Additional tool specific flags</param>
      <param name="runtimeVersion">Runtime version</param>
      <returns>
        <see cref="T:Llvm.NET.DebugInfo.DICompileUnit" />
      </returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateEnumerationType(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt64,System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DIEnumerator},Llvm.NET.DebugInfo.DIType,System.String)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateEnumeratorValue(System.String,System.Int64)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateExpression(Llvm.NET.DebugInfo.ExpressionOp[])"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateExpression(System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.ExpressionOp})"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateFile(System.String)">
      <summary>Creates a <see cref="T:Llvm.NET.DebugInfo.DIFile" /></summary>
      <param name="path">Path of the file (may be <see langword="null" /> or empty)</param>
      <returns>
        <see cref="T:Llvm.NET.DebugInfo.DIFile" /> or <see langword="null" /> if <paramref name="path" />
            is <see langword="null" /> empty, or all whitespace
            </returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateFile(System.String,System.String)">
      <summary>Creates a <see cref="T:Llvm.NET.DebugInfo.DIFile" /></summary>
      <param name="fileName">Name of the file (may be <see langword="null" /> or empty)</param>
      <param name="directory">Path of the directory containing the file (may be <see langword="null" /> or empty)</param>
      <returns>
        <see cref="T:Llvm.NET.DebugInfo.DIFile" /> or <see langword="null" /> if <paramref name="fileName" />
            is <see langword="null" /> empty, or all whitespace
            </returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateFunction(Llvm.NET.DebugInfo.DIScope,System.String,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DISubroutineType,System.Boolean,System.Boolean,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Boolean,Llvm.NET.Values.Function,Llvm.NET.MDNode,Llvm.NET.MDNode)">
      <summary>Create a <see cref="T:Llvm.NET.DebugInfo.DISubProgram" /> with debug information</summary>
      <param name="scope">
        <see cref="T:Llvm.NET.DebugInfo.DIScope" /> for the function</param>
      <param name="name">Name of the function as it appears in the source language</param>
      <param name="mangledName">Linkage (mangled) name of the function</param>
      <param name="file">
        <see cref="T:Llvm.NET.DebugInfo.DIFile" /> containing the function</param>
      <param name="line">starting line of the function definition</param>
      <param name="signatureType">
        <see cref="T:Llvm.NET.DebugInfo.DISubroutineType" /> for the function's signature type</param>
      <param name="isLocalToUnit">Flag to indicate if this function is local to the compilation unit or available externally</param>
      <param name="isDefinition">Flag to indicate if this is a definition or a declaration only</param>
      <param name="scopeLine">starting line of the first scope of the function's body</param>
      <param name="debugFlags">
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoFlags" /> for this function</param>
      <param name="isOptimized">Flag to indicate if this function is optimized</param>
      <param name="function">Underlying LLVM <see cref="T:Llvm.NET.Values.Function" /> to attach debug info to</param>
      <param name="typeParameter">Template parameter [default = null]</param>
      <param name="declaration">Template declarations [default = null]</param>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateGlobalVariable(Llvm.NET.DebugInfo.DINode,System.String,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DIType,System.Boolean,Llvm.NET.Values.Value,Llvm.NET.DebugInfo.DINode)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateLexicalBlock(Llvm.NET.DebugInfo.DIScope,Llvm.NET.DebugInfo.DIFile,System.UInt32,System.UInt32)">
      <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DILexicalBlock" /></summary>
      <param name="scope">
        <see cref="T:Llvm.NET.DebugInfo.DIScope" /> for the block</param>
      <param name="file">
        <see cref="T:Llvm.NET.DebugInfo.DIFile" /> containing the block</param>
      <param name="line">Starting line number for the block</param>
      <param name="column">Starting column for the block</param>
      <returns>
        <see cref="T:Llvm.NET.DebugInfo.DILexicalBlock" /> created from the parameters
            </returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateLexicalBlockFile(Llvm.NET.DebugInfo.DIScope,Llvm.NET.DebugInfo.DIFile,System.UInt32)">
      <summary>Creates a <see cref="T:Llvm.NET.DebugInfo.DILexicalBlockFile" /></summary>
      <param name="scope">
        <see cref="T:Llvm.NET.DebugInfo.DIScope" /> for the block</param>
      <param name="file">
        <see cref="T:Llvm.NET.DebugInfo.DIFile" />
      </param>
      <param name="discriminator">Discriminator to disambiguate lexical blocks with the same file info</param>
      <returns>
        <see cref="T:Llvm.NET.DebugInfo.DILexicalBlockFile" /> constructed from the parameters
            </returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateLocalVariable(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DIType,System.Boolean,Llvm.NET.DebugInfo.DebugInfoFlags)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateMemberType(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt64,System.UInt64,Llvm.NET.DebugInfo.DebugInfoFlags,Llvm.NET.DebugInfo.DIType)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateNamespace(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32)">
      <summary>Creates a <see cref="T:Llvm.NET.DebugInfo.DINamespace" /></summary>
      <param name="scope">Containing scope for the namespace or null if the namespace is a global one</param>
      <param name="name">Name of the namespace</param>
      <param name="file">Source file containing the declaration (may be null if more than one or not known)</param>
      <param name="line">Line number of the namespace declaration</param>
      <returns></returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreatePointerType(Llvm.NET.DebugInfo.DIType,System.String,System.UInt64,System.UInt64)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateQualifiedType(Llvm.NET.DebugInfo.DIType,Llvm.NET.DebugInfo.QualifiedTypeTag)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateReplaceableCompositeType(Llvm.NET.DebugInfo.Tag,System.String,Llvm.NET.DebugInfo.DINode,Llvm.NET.DebugInfo.DIFile,System.UInt32,System.UInt32,System.UInt64,System.UInt64,Llvm.NET.DebugInfo.DebugInfoFlags)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateStructType(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt64,Llvm.NET.DebugInfo.DebugInfoFlags,Llvm.NET.DebugInfo.DIType,Llvm.NET.DebugInfo.DINode[])"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateStructType(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt64,Llvm.NET.DebugInfo.DebugInfoFlags,Llvm.NET.DebugInfo.DIType,System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DINode})"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateStructType(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,System.UInt64,System.UInt64,System.UInt32,Llvm.NET.DebugInfo.DIType,Llvm.NET.DebugInfo.DINodeArray)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateSubRange(System.Int64,System.Int64)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateSubroutineType(Llvm.NET.DebugInfo.DebugInfoFlags)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateSubroutineType(Llvm.NET.DebugInfo.DebugInfoFlags,Llvm.NET.DebugInfo.DIType,System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DIType})"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateSubroutineType(Llvm.NET.DebugInfo.DebugInfoFlags,Llvm.NET.DebugInfo.DITypeArray)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateTypeArray(Llvm.NET.DebugInfo.DIType[])"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateTypeArray(System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DIType})"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateTypedef(Llvm.NET.DebugInfo.DIType,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DINode)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.DebugInfo.DebugInfoBuilder</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.Finish"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.ForwardDeclareFunction(Llvm.NET.DebugInfo.DIScope,System.String,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DISubroutineType,System.Boolean,System.Boolean,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Boolean)">
      <summary>Creates a new forward declaration to a function</summary>
      <param name="scope">
        <see cref="T:Llvm.NET.DebugInfo.DIScope" /> for the declaration</param>
      <param name="name">Name of the function as it appears in source</param>
      <param name="mangledName">mangled name of the function (for linker)</param>
      <param name="file">Source file location for the function</param>
      <param name="line">starting line of the declaration</param>
      <param name="subroutineType">Signature for the function</param>
      <param name="isLocalToUnit">Flag to indicate if this declaration is local to the compilation unit</param>
      <param name="isDefinition">Flag to indicate if this is a definition</param>
      <param name="scopeLine">Line of the first scope block</param>
      <param name="debugFlags">
        <see cref="T:Llvm.NET.DebugInfo.DebugInfoFlags" /> for the function</param>
      <param name="isOptimized">Flag to indicate if the function is optimized</param>
      <returns></returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.GetOrCreateArray(System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DINode})"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.GetOrCreateTypeArray(Llvm.NET.DebugInfo.DIType[])"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.GetOrCreateTypeArray(System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DIType})"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertDeclare(Llvm.NET.Values.Value,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DIExpression,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Instructions.Instruction)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertDeclare(Llvm.NET.Values.Value,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DIExpression,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Values.BasicBlock)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertDeclare(Llvm.NET.Values.Value,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Instructions.Instruction)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertDeclare(Llvm.NET.Values.Value,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Values.BasicBlock)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertValue(Llvm.NET.Values.Value,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DIExpression,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Values.BasicBlock)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertValue(Llvm.NET.Values.Value,System.UInt64,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DIExpression,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Instructions.Instruction)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertValue(Llvm.NET.Values.Value,System.UInt64,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DIExpression,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Values.BasicBlock)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertValue(Llvm.NET.Values.Value,System.UInt64,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Instructions.Instruction)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertValue(Llvm.NET.Values.Value,System.UInt64,Llvm.NET.DebugInfo.DILocalVariable,Llvm.NET.DebugInfo.DILocation,Llvm.NET.Values.BasicBlock)"></member>
    <member name="T:Llvm.NET.DebugInfo.DebugInfoFlags">
      <summary>Accessibility flags</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugMemberInfo">
      <summary>Describes a member/field of a type for creating debug information</summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugMemberInfo.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.DebugInfo.DebugMemberInfo</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.DebugInfoFlags">
      <summary>flags for the field declaration</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.DebugType">
      <summary>Debug type information for this field</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.ExplicitLayout">
      <summary>Provides explicit layout information for this member</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.File">
      <summary>File the field is declared in</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.Index">
      <summary>LLVM structure element index this descriptor describes</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.Line">
      <summary>Line the field is declared on</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.Name">
      <summary>Name of the field</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugMemberLayout">
      <summary>DebugMemberLayout is used to define custom layout information for structure members</summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugMemberLayout.#ctor(System.UInt32,System.UInt32,System.UInt64)">
      <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugMemberLayout" /></summary>
      <param name="bitSize">Size of the member in bits</param>
      <param name="bitAlignment">Alignment of the member in bits</param>
      <param name="bitOffset">Offset of the member in bits</param>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberLayout.BitAlignment">
      <summary>Bit alignment for the field</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberLayout.BitOffset">
      <summary>Bit offset for the field in it's containing type</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugMemberLayout.BitSize">
      <summary>Bit size for the field</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugPointerType">
      <summary>Binding between a <see cref="T:Llvm.NET.DebugInfo.DIDerivedType" /> and an <see cref="T:Llvm.NET.Types.IPointerType" /></summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugPointerType.#ctor(Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.NativeModule,System.UInt32,System.String)">
      <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugPointerType" /></summary>
      <param name="debugElementType">Debug type of the pointee</param>
      <param name="module">
        <see cref="T:Llvm.NET.NativeModule" /> used for creating the pointer type and debug information</param>
      <param name="addressSpace">Target address space for the pointer [Default: 0]</param>
      <param name="name">Name of the type [Default: null]</param>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugPointerType.#ctor(Llvm.NET.Types.IPointerType,Llvm.NET.DebugInfo.DIDerivedType)">
      <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugPointerType" /></summary>
      <param name="llvmPtrType">Native type of the pointer</param>
      <param name="debugType">Debug type for the pointer</param>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugPointerType.#ctor(Llvm.NET.Types.IPointerType,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIType,System.String)">
      <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugPointerType" /></summary>
      <param name="llvmPtrType">Native type of the pointer</param>
      <param name="module">
        <see cref="T:Llvm.NET.NativeModule" /> used for creating the pointer type and debug information</param>
      <param name="elementType">Debug type of the pointee</param>
      <param name="name">Name of the type [Default: null]</param>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugPointerType.#ctor(Llvm.NET.Types.ITypeRef,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIType,System.UInt32,System.String)">
      <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugPointerType" /></summary>
      <param name="llvmElementType">Native type of the pointee</param>
      <param name="module">
        <see cref="T:Llvm.NET.NativeModule" /> used for creating the pointer type and debug information</param>
      <param name="elementType">Debug type of the pointee</param>
      <param name="addressSpace">Target address space for the pointer [Default: 0]</param>
      <param name="name">Name of the type [Default: null]</param>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugPointerType.AddressSpace">
      <summary>Address space the pointer refers to</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugPointerType.ElementType">
      <summary>Type of elements in the sequence</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugStructType"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugStructType.#ctor(Llvm.NET.NativeModule,System.String,Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.DebugInfo.DebugStructType</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugStructType.#ctor(Llvm.NET.Types.IStructType,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.DebugInfo.DebugStructType</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugStructType.#ctor(Llvm.NET.Types.IStructType,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,Llvm.NET.DebugInfo.DIType,System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DIType})">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.DebugInfo.DebugStructType</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DebugStructType.DebugMembers"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugStructType.IsOpaque"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugStructType.IsPacked"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugStructType.Members"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugStructType.Name"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugStructType.SetBody(System.Boolean,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIScope,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DebugMemberInfo})"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugStructType.SetBody(System.Boolean,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIScope,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Llvm.NET.Types.ITypeRef},System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DebugMemberInfo},System.Nullable{System.UInt32},System.Nullable{System.UInt32})"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugStructType.SetBody(System.Boolean,Llvm.NET.Types.ITypeRef[])"></member>
    <member name="T:Llvm.NET.DebugInfo.DebugType"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType.Create``2(``0,``1)">
      <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DebugType" />instance inferring the generic arguments from the parameters</summary>
      <param name="nativeType">
        <typeparamref name="TNative" /> type instance for this association</param>
      <param name="debugType">
        <typeparamref name="TDebug" /> type instance for this association</param>
      <typeparam name="TNative">Type of the Native LLVM type for the association</typeparam>
      <typeparam name="TDebug">Type of the debug information type for the association</typeparam>
      <returns>
        <see cref="T:Llvm.NET.DebugInfo.IDebugType`2" /> implementation for the specified association</returns>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DebugType.HasDebugInfo(Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType})">
      <summary>Convenience extensions for determining if the <see cref="T:Llvm.NET.DebugInfo.DIType" /> property is valid</summary>
      <param name="debugType"></param>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DebugType`2"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.AddExtendedPropertyValue(System.String,System.Object)"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.Context"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.CreateArrayType(Llvm.NET.NativeModule,System.UInt32,System.UInt32)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.CreateArrayType(System.UInt32)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.CreatePointerType"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.CreatePointerType(Llvm.NET.NativeModule,System.UInt32)"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.CreatePointerType(System.UInt32)"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.DIType"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.GetNullValue"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IntegerBitWidth"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsDouble"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsFloat"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsFloatingPoint"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsInteger"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsPointer"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsPointerPointer"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsSequence"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsSized"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsStruct"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.IsVoid"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.Kind"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.NativeType"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.op_Implicit(Llvm.NET.DebugInfo.DebugType{`0,`1})~`1"></member>
    <member name="M:Llvm.NET.DebugInfo.DebugType`2.TryGetExtendedPropertyValue``1(System.String,``0@)"></member>
    <member name="P:Llvm.NET.DebugInfo.DebugType`2.TypeHandle"></member>
    <member name="T:Llvm.NET.DebugInfo.DIBasicType">
      <summary>Debug information for a basic type</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DICompileUnit">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#dicompileunit" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DICompositeType">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#dicompositetype" /></summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DICompositeType.BaseType"></member>
    <member name="P:Llvm.NET.DebugInfo.DICompositeType.Elements"></member>
    <member name="T:Llvm.NET.DebugInfo.DIDerivedType">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#diderivedtype" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DIEnumerator">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#dienumerator" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DIExpression">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#diexpression" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DIFile">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#difile" /></summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DIFile.Directory"></member>
    <member name="P:Llvm.NET.DebugInfo.DIFile.FileName"></member>
    <member name="P:Llvm.NET.DebugInfo.DIFile.Path"></member>
    <member name="T:Llvm.NET.DebugInfo.DIGlobalVariable">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#diglobalvariable" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DIImportedEntity">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#diImportedEntity" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DILexicalBlock">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#dilexicalblock" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DILexicalBlockBase"></member>
    <member name="T:Llvm.NET.DebugInfo.DILexicalBlockFile">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#dilexicalblockfile" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DILocalScope">
      <summary>Legal scope for lexical blocks, local variables, and debug info locations</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DILocalScope.SubProgram"></member>
    <member name="T:Llvm.NET.DebugInfo.DILocalVariable">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#dilocalvariable" /></summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DILocalVariable.Scope"></member>
    <member name="T:Llvm.NET.DebugInfo.DILocation"></member>
    <member name="M:Llvm.NET.DebugInfo.DILocation.#ctor(Llvm.NET.Context,System.UInt32,System.UInt32,Llvm.NET.DebugInfo.DILocalScope)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.DebugInfo.DILocation</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DILocation.#ctor(Llvm.NET.Context,System.UInt32,System.UInt32,Llvm.NET.DebugInfo.DILocalScope,Llvm.NET.DebugInfo.DILocation)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.DebugInfo.DILocation</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DILocation.Column"></member>
    <member name="M:Llvm.NET.DebugInfo.DILocation.Describes(Llvm.NET.Values.Function)"></member>
    <member name="P:Llvm.NET.DebugInfo.DILocation.InlinedAt"></member>
    <member name="P:Llvm.NET.DebugInfo.DILocation.InlinedAtScope"></member>
    <member name="P:Llvm.NET.DebugInfo.DILocation.Line"></member>
    <member name="P:Llvm.NET.DebugInfo.DILocation.Scope"></member>
    <member name="M:Llvm.NET.DebugInfo.DILocation.ToString"></member>
    <member name="T:Llvm.NET.DebugInfo.DIModule"></member>
    <member name="T:Llvm.NET.DebugInfo.DINamespace">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#dinamespace" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DINode">
      <summary>Root of the object hierarchy for Debug information metadata nodes</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DINode.Tag">
      <summary>Dwarf tag for the descriptor</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DINodeArray">
      <summary>Array of <see cref="T:Llvm.NET.DebugInfo.DINode" /> debug information nodes for use with <see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder" /> methods</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DIObjCProperty"></member>
    <member name="T:Llvm.NET.DebugInfo.DIScope">
      <summary>Base class for all Debug info scopes</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DIScope.File"></member>
    <member name="T:Llvm.NET.DebugInfo.DISubProgram">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#disubprogram" /></summary>
    </member>
    <member name="M:Llvm.NET.DebugInfo.DISubProgram.Describes(Llvm.NET.Values.Function)"></member>
    <member name="T:Llvm.NET.DebugInfo.DISubRange">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#disubrange" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DISubroutineType">
      <summary>see <a href="http://llvm.org/docs/LangRef.html#disubroutinetype" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DITemplateParameter"></member>
    <member name="T:Llvm.NET.DebugInfo.DITemplateTypeParameter"></member>
    <member name="T:Llvm.NET.DebugInfo.DITemplateValueParameter"></member>
    <member name="T:Llvm.NET.DebugInfo.DIType">
      <summary>Base class for Debug info types</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.DIType.BitAlignment"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.BitOffset"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.BitSize"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.DebugInfoFlags"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsAppleBlockExtension"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsArtificial"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsBlockByRefStruct"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsForwardDeclaration"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsLvalueReference"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsObjClassComplete"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsObjectPointer"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsPrivate"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsProtected"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsPublic"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsRvalueReference"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsStaticMember"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsVector"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.IsVirtual"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.Line"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.Name"></member>
    <member name="P:Llvm.NET.DebugInfo.DIType.Scope"></member>
    <member name="T:Llvm.NET.DebugInfo.DITypeArray">
      <summary>Array of see <a href="Type" /> nodes for use with see <a href="DebugInfoBuilder" /> methods</summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.DiTypeKind"></member>
    <member name="T:Llvm.NET.DebugInfo.DIVariable"></member>
    <member name="P:Llvm.NET.DebugInfo.DIVariable.File"></member>
    <member name="P:Llvm.NET.DebugInfo.DIVariable.Name"></member>
    <member name="P:Llvm.NET.DebugInfo.DIVariable.Scope"></member>
    <member name="P:Llvm.NET.DebugInfo.DIVariable.Type"></member>
    <member name="T:Llvm.NET.DebugInfo.ExpressionOp"></member>
    <member name="T:Llvm.NET.DebugInfo.GenericDINode"></member>
    <member name="T:Llvm.NET.DebugInfo.IDebugType`2">
      <summary>Provides pairing of a <see cref="T:Llvm.NET.Types.ITypeRef" /> with a <see cref="P:Llvm.NET.DebugInfo.IDebugType`2.DIType" /> for function signatures</summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.IDebugType`2.DIType">
      <summary>Debug information type this interface is associating with <see cref="P:Llvm.NET.DebugInfo.IDebugType`2.NativeType" /></summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.IDebugType`2.NativeType">
      <summary>LLVM NativeType this interface is associating with debug info in <see cref="P:Llvm.NET.DebugInfo.IDebugType`2.DIType" /></summary>
    </member>
    <member name="T:Llvm.NET.DebugInfo.QualifiedTypeTag"></member>
    <member name="T:Llvm.NET.DebugInfo.SourceLanguage"></member>
    <member name="T:Llvm.NET.DebugInfo.Tag"></member>
    <member name="T:Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1">
      <summary>Generic wrapper to treat an MDTuple as an array of elements of specific type</summary>
      <typeparam name="T">Type of elements</typeparam>
    </member>
    <member name="M:Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1.#ctor(Llvm.NET.MDTuple)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1.Count"></member>
    <member name="M:Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1.GetEnumerator"></member>
    <member name="P:Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1.Item(System.Int32)"></member>
    <member name="M:Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Returns an enumerator that iterates through a collection.</summary>
      <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
    </member>
    <member name="P:Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1.Tuple"></member>
    <member name="T:Llvm.NET.Instructions.Alloca"></member>
    <member name="T:Llvm.NET.Instructions.AtomicCmpXchg"></member>
    <member name="T:Llvm.NET.Instructions.AtomicRMW"></member>
    <member name="T:Llvm.NET.Instructions.BinaryOperator"></member>
    <member name="T:Llvm.NET.Instructions.BitCast"></member>
    <member name="T:Llvm.NET.Instructions.Branch"></member>
    <member name="T:Llvm.NET.Instructions.CallInstruction"></member>
    <member name="P:Llvm.NET.Instructions.CallInstruction.Attributes"></member>
    <member name="P:Llvm.NET.Instructions.CallInstruction.IsTailCall"></member>
    <member name="P:Llvm.NET.Instructions.CallInstruction.TargetFunction"></member>
    <member name="T:Llvm.NET.Instructions.Cast"></member>
    <member name="T:Llvm.NET.Instructions.CatchPad"></member>
    <member name="T:Llvm.NET.Instructions.CatchReturn"></member>
    <member name="T:Llvm.NET.Instructions.CatchSwitch"></member>
    <member name="T:Llvm.NET.Instructions.CleanupPad"></member>
    <member name="T:Llvm.NET.Instructions.CleanupReturn"></member>
    <member name="T:Llvm.NET.Instructions.Cmp"></member>
    <member name="P:Llvm.NET.Instructions.Cmp.Predicate"></member>
    <member name="T:Llvm.NET.Instructions.DebugDeclare"></member>
    <member name="T:Llvm.NET.Instructions.DebugInfoIntrinsic"></member>
    <member name="T:Llvm.NET.Instructions.ExtractElement"></member>
    <member name="T:Llvm.NET.Instructions.ExtractValue"></member>
    <member name="T:Llvm.NET.Instructions.FCmp"></member>
    <member name="T:Llvm.NET.Instructions.Fence"></member>
    <member name="T:Llvm.NET.Instructions.FuncletPad"></member>
    <member name="T:Llvm.NET.Instructions.GetElementPtr"></member>
    <member name="T:Llvm.NET.Instructions.IndirectBranch"></member>
    <member name="T:Llvm.NET.Instructions.InsertElement"></member>
    <member name="T:Llvm.NET.Instructions.InsertValue"></member>
    <member name="T:Llvm.NET.Instructions.Instruction">
      <summary>Exposes an LLVM Instruction</summary>
    </member>
    <member name="P:Llvm.NET.Instructions.Instruction.Alignment">
      <summary>Alignment for the instruction</summary>
    </member>
    <member name="P:Llvm.NET.Instructions.Instruction.ContainingBlock">
      <summary>Block that contains this instruction</summary>
    </member>
    <member name="P:Llvm.NET.Instructions.Instruction.IsMemoryAccess">
      <summary>FLag to indicate if the opcode is for a memory access <see cref="T:Llvm.NET.Instructions.Alloca" />, <see cref="T:Llvm.NET.Instructions.Load" />, <see cref="T:Llvm.NET.Instructions.Store" /></summary>
    </member>
    <member name="P:Llvm.NET.Instructions.Instruction.Opcode">
      <summary>Gets the LLVM opcode for the instruction</summary>
    </member>
    <member name="T:Llvm.NET.Instructions.InstructionBuilder">
      <summary>LLVM Instruction builder allowing managed code to generate IR instructions</summary>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.#ctor(Llvm.NET.Context)">
      <summary>Creates an <see cref="T:Llvm.NET.Instructions.InstructionBuilder" /> for a given context</summary>
      <param name="context">Context used for creating instructions</param>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.#ctor(Llvm.NET.Values.BasicBlock)">
      <summary>Creates an <see cref="T:Llvm.NET.Instructions.InstructionBuilder" /> for a <see cref="T:Llvm.NET.Values.BasicBlock" /></summary>
      <param name="block">Block this builder is initially attached to</param>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Add(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Alloca(Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Alloca(Llvm.NET.Types.ITypeRef,Llvm.NET.Values.ConstantInt)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.And(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.ArithmeticShiftRight(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicAdd(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicAnd(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicCmpXchg(Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicMax(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicMin(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicNand(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicOr(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicSub(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicUMax(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicUMin(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicXchg(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.AtomicXor(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.BitCast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Branch(Llvm.NET.Values.BasicBlock)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Branch(Llvm.NET.Values.Value,Llvm.NET.Values.BasicBlock,Llvm.NET.Values.BasicBlock)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Call(Llvm.NET.Values.Value,Llvm.NET.Values.Value[])"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Call(Llvm.NET.Values.Value,System.Collections.Generic.IReadOnlyList{Llvm.NET.Values.Value})"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Compare(Llvm.NET.IntPredicate,Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
      <summary>Builds an Integer compare instruction</summary>
      <param name="predicate">Integer predicate for the comparison</param>
      <param name="lhs">Left hand side of the comparison</param>
      <param name="rhs">Right hand side of the comparison</param>
      <returns>Comparison instruction</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Compare(Llvm.NET.Predicate,Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
      <summary>Builds a compare instruction</summary>
      <param name="predicate">predicate for the comparison</param>
      <param name="lhs">Left hand side of the comparison</param>
      <param name="rhs">Right hand side of the comparison</param>
      <returns>Comparison instruction</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Compare(Llvm.NET.RealPredicate,Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
      <summary>Builds a Floating point compare instruction</summary>
      <param name="predicate">predicate for the comparison</param>
      <param name="lhs">Left hand side of the comparison</param>
      <param name="rhs">Right hand side of the comparison</param>
      <returns>Comparison instruction</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.ConstGetElementPtrInBounds(Llvm.NET.Values.Value,Llvm.NET.Values.Value[])">
      <summary>Creates a <see cref="T:Llvm.NET.Values.Value" /> that accesses an element of a type referenced by a pointer</summary>
      <param name="pointer">pointer to get an element from</param>
      <param name="args">additional indices for computing the resulting pointer</param>
      <returns>
        <para>
          <see cref="T:Llvm.NET.Values.Value" /> for the member access. This is a User as LLVM may 
            optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression" /> if it 
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression" />
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr" />.</para>
        <para>Note that <paramref name="pointer" /> must be a pointer to a structure
            or an exception is thrown.</para>
      </returns>
    </member>
    <member name="P:Llvm.NET.Instructions.InstructionBuilder.Context">
      <summary>Gets the context this builder is creating instructions for</summary>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.DebugTrap(Llvm.NET.NativeModule)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Dispose">
      <summary>
        <markup>
          <include item="SMCAutoDocDispose">
            <parameter>Llvm.NET.Instructions.InstructionBuilder</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Dispose(System.Boolean)">
      <summary>
        <markup>
          <include item="SMCAutoDocDisposeBool">
            <parameter>Llvm.NET.Instructions.InstructionBuilder</parameter>
          </include>
        </markup>
      </summary>
      <param name="disposing">
        <markup>
          <include item="SMCAutoDocDisposeParam">
            <parameter>Llvm.NET.Instructions.InstructionBuilder</parameter>
          </include>
        </markup>
      </param>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.DoNothing(Llvm.NET.NativeModule)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.ExtractValue(Llvm.NET.Values.Value,System.UInt32)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FAdd(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FDiv(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Finalize"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FMul(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FNeg(Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FPExt(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FPToSICast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FPToUICast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FPTrunc(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FRem(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.FSub(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.GetElementPtr(Llvm.NET.Values.Value,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Value})">
      <summary>Creates a <see cref="T:Llvm.NET.Values.Value" /> that accesses an element of a type referenced by a pointer</summary>
      <param name="pointer">pointer to get an element from</param>
      <param name="args">additional indices for computing the resulting pointer</param>
      <returns>
        <para>
          <see cref="T:Llvm.NET.Values.Value" /> for the member access. This is a <see cref="T:Llvm.NET.Values.Value" />
            as LLVM may optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression" /> if it 
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression" />
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr" />.</para>
        <para>Note that <paramref name="pointer" /> must be a pointer to a structure
            or an exception is thrown.</para>
      </returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.GetElementPtrInBounds(Llvm.NET.Values.Value,Llvm.NET.Values.Value[])">
      <summary>Creates a <see cref="T:Llvm.NET.Values.Value" /> that accesses an element of a type referenced by a pointer</summary>
      <param name="pointer">pointer to get an element from</param>
      <param name="args">additional indices for computing the resulting pointer</param>
      <returns>
        <para>
          <see cref="T:Llvm.NET.Values.Value" /> for the member access. This is a <see cref="T:Llvm.NET.Values.Value" />
            as LLVM may optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression" /> if it 
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression" />
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr" />.</para>
        <para>Note that <paramref name="pointer" /> must be a pointer to a structure
            or an exception is thrown.</para>
      </returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.GetElementPtrInBounds(Llvm.NET.Values.Value,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Value})">
      <summary>Creates a <see cref="T:Llvm.NET.Values.Value" /> that accesses an element of a type referenced by a pointer</summary>
      <param name="pointer">pointer to get an element from</param>
      <param name="args">additional indices for computing the resulting pointer</param>
      <returns>
        <para>
          <see cref="T:Llvm.NET.Values.Value" /> for the member access. This is a <see cref="T:Llvm.NET.Values.Value" />
            as LLVM may optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression" /> if it 
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression" />
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr" />.</para>
        <para>Note that <paramref name="pointer" /> must be a pointer to a structure
            or an exception is thrown.</para>
      </returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.GetStructElementPointer(Llvm.NET.Values.Value,System.UInt32)">
      <summary>Creates a <see cref="T:Llvm.NET.Values.Value" /> that accesses an element (field) of a structure</summary>
      <param name="pointer">pointer to the structure to get an element from</param>
      <param name="index">element index</param>
      <returns>
        <para>
          <see cref="T:Llvm.NET.Values.Value" /> for the member access. This is a <see cref="T:Llvm.NET.Values.Value" />
            as LLVM may optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression" /> if it
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression" />
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr" />.</para>
        <para>Note that <paramref name="pointer" /> must be a pointer to a structure
            or an exception is thrown.</para>
      </returns>
    </member>
    <member name="P:Llvm.NET.Instructions.InstructionBuilder.InsertBlock"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.InsertValue(Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.UInt32)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.IntCast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef,System.Boolean)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.IntToPointer(Llvm.NET.Values.Value,Llvm.NET.Types.IPointerType)">
      <summary>Builds a cast from an integer to a pointer</summary>
      <param name="intValue">Integer value to cast</param>
      <param name="ptrType">pointer type to return</param>
      <returns>Resulting value from the cast</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Invoke(Llvm.NET.Values.Value,System.Collections.Generic.IReadOnlyList{Llvm.NET.Values.Value},Llvm.NET.Values.BasicBlock,Llvm.NET.Values.BasicBlock)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.LandingPad(Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Load(Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.LogicalShiftRight(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemCpy(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
      <summary>Builds a memcpy intrinsic call</summary>
      <param name="module">Module to add the declaration of the intrinsic to if it doesn't already exist</param>
      <param name="destination">Destination pointer of the memcpy</param>
      <param name="source">Source pointer of the memcpy</param>
      <param name="len">length of the data to copy</param>
      <param name="align">Alignment of the data for the copy</param>
      <param name="isVolatile">Flag to indicate if the copy involves volatile data such as physical registers</param>
      <returns>
        <see cref="T:Llvm.NET.Instructions.Intrinsic" /> call for the memcpy</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemMove(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
      <summary>Builds a memmov intrinsic call</summary>
      <param name="module">Module to add the declaration of the intrinsic to if it doesn't already exist</param>
      <param name="destination">Destination pointer of the memcpy</param>
      <param name="source">Source pointer of the memcpy</param>
      <param name="len">length of the data to copy</param>
      <param name="align">Alignment of the data for the copy</param>
      <param name="isVolatile">Flag to indicate if the copy involves volatile data such as physical registers</param>
      <returns>
        <see cref="T:Llvm.NET.Instructions.Intrinsic" /> call for the memcpy</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemSet(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
      <summary>Builds a memset intrinsic call</summary>
      <param name="module">Module to add the declaration of the intrinsic to if it doesn't already exist</param>
      <param name="destination">Destination pointer of the memset</param>
      <param name="value">fill value for the memset</param>
      <param name="len">length of the data to fill</param>
      <param name="align">ALignment of the data for the fill</param>
      <param name="isVolatile">Flag to indicate if the fill involves volatile data such as physical registers</param>
      <returns>
        <see cref="T:Llvm.NET.Instructions.Intrinsic" /> call for the memcpy</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Mul(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Neg(Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Not(Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Or(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.PhiNode(Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.PointerToInt(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)">
      <summary>Builds a cast from a pointer to an integer type</summary>
      <param name="ptrValue">Pointer value to cast</param>
      <param name="intType">Integer type to return</param>
      <returns>Resulting value from the cast</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.PositionAtEnd(Llvm.NET.Values.BasicBlock)">
      <summary>Positions the builder at the end of a given <see cref="T:Llvm.NET.Values.BasicBlock" /></summary>
      <param name="basicBlock"></param>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.PositionBefore(Llvm.NET.Instructions.Instruction)">
      <summary>Positions the builder before the given instruction</summary>
      <param name="instr">Instruction to position the builder before</param>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Resume(Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Return"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Return(Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.SDiv(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.ShiftLeft(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.SignExtend(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.SignExtendOrBitCast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.SIToFPCast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.SRem(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Store(Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
      <summary>Builds an LLVM Store instruction</summary>
      <param name="value">Value to store in destination</param>
      <param name="destination">value for the destination</param>
      <returns>
        <see cref="T:Llvm.NET.Instructions.Store" /> instruction</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Sub(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Switch(Llvm.NET.Values.Value,Llvm.NET.Values.BasicBlock,System.UInt32)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Trunc(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.TruncOrBitCast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.UDiv(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.UIToFPCast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Unreachable"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.URem(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.Xor(Llvm.NET.Values.Value,Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.ZeroExtend(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Instructions.InstructionBuilder.ZeroExtendOrBitCast(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)"></member>
    <member name="T:Llvm.NET.Instructions.InstructionExtensions">
      <summary>Provides extension methods to <see cref="T:Llvm.NET.Instructions.Instruction" /> that cannot be achieved as members of the class</summary>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionExtensions.Alignment``1(``0,System.UInt32)">
      <summary>Fluent style extension method to set the <see cref="P:Llvm.NET.Instructions.Instruction.Alignment" /> for an instruction</summary>
      <param name="self">Instruction to set the <see cref="P:Llvm.NET.Instructions.Instruction.Alignment" /> for</param>
      <param name="value">New alignment for the instruction</param>
      <typeparam name="T">Type of the instruction (usually implicitly inferred from usage)</typeparam>
      <returns>To allow fluent style coding this returns the <paramref name="self" /> parameter</returns>
    </member>
    <member name="M:Llvm.NET.Instructions.InstructionExtensions.IsVolatile``1(``0,System.Boolean)">
      <summary>Fluent style extension method to set the Volatile property of a <see cref="T:Llvm.NET.Instructions.Load" /> or <see cref="T:Llvm.NET.Instructions.Store" /> instruction</summary>
      <param name="self">Instruction to set the Volatile property for</param>
      <param name="value">Flag to indicate if the instruction's operation is volatile</param>
      <typeparam name="T">Type of the instruction (usually implicitly inferred from usage)</typeparam>
      <returns>To allow fluent style coding this returns the <paramref name="self" /> parameter</returns>
    </member>
    <member name="T:Llvm.NET.Instructions.IntCmp"></member>
    <member name="T:Llvm.NET.Instructions.Intrinsic"></member>
    <member name="T:Llvm.NET.Instructions.IntToPointer"></member>
    <member name="T:Llvm.NET.Instructions.Invoke"></member>
    <member name="P:Llvm.NET.Instructions.Invoke.Attributes"></member>
    <member name="P:Llvm.NET.Instructions.Invoke.TargetFunction"></member>
    <member name="T:Llvm.NET.Instructions.LandingPad"></member>
    <member name="M:Llvm.NET.Instructions.LandingPad.AddClause(Llvm.NET.Values.Value)"></member>
    <member name="M:Llvm.NET.Instructions.LandingPad.SetCleanup(System.Boolean)"></member>
    <member name="T:Llvm.NET.Instructions.Load"></member>
    <member name="P:Llvm.NET.Instructions.Load.IsVolatile"></member>
    <member name="T:Llvm.NET.Instructions.MemCpy"></member>
    <member name="T:Llvm.NET.Instructions.MemIntrinsic"></member>
    <member name="T:Llvm.NET.Instructions.MemMove"></member>
    <member name="T:Llvm.NET.Instructions.MemSet"></member>
    <member name="T:Llvm.NET.Instructions.PhiNode"></member>
    <member name="M:Llvm.NET.Instructions.PhiNode.AddIncoming(Llvm.NET.Values.Value,Llvm.NET.Values.BasicBlock)"></member>
    <member name="M:Llvm.NET.Instructions.PhiNode.AddIncoming(System.Tuple{Llvm.NET.Values.Value,Llvm.NET.Values.BasicBlock},System.Tuple{Llvm.NET.Values.Value,Llvm.NET.Values.BasicBlock}[])"></member>
    <member name="T:Llvm.NET.Instructions.PointerToInt"></member>
    <member name="T:Llvm.NET.Instructions.ResumeInstruction"></member>
    <member name="T:Llvm.NET.Instructions.ReturnInstruction"></member>
    <member name="T:Llvm.NET.Instructions.Select"></member>
    <member name="T:Llvm.NET.Instructions.ShuffleVector"></member>
    <member name="T:Llvm.NET.Instructions.SignExtend"></member>
    <member name="T:Llvm.NET.Instructions.Store"></member>
    <member name="P:Llvm.NET.Instructions.Store.IsVolatile"></member>
    <member name="T:Llvm.NET.Instructions.Switch"></member>
    <member name="M:Llvm.NET.Instructions.Switch.AddCase(Llvm.NET.Values.Value,Llvm.NET.Values.BasicBlock)">
      <summary>Adds a new case to the <see cref="T:Llvm.NET.Instructions.Switch" /> instruction</summary>
      <param name="onVal">Value for the case to match</param>
      <param name="destination">Destination <see cref="T:Llvm.NET.Values.BasicBlock" /> if the case matches</param>
    </member>
    <member name="P:Llvm.NET.Instructions.Switch.Default">
      <summary>Default <see cref="T:Llvm.NET.Values.BasicBlock" />for the switch</summary>
    </member>
    <member name="T:Llvm.NET.Instructions.Terminator"></member>
    <member name="T:Llvm.NET.Instructions.Trunc"></member>
    <member name="T:Llvm.NET.Instructions.UnaryInstruction"></member>
    <member name="T:Llvm.NET.Instructions.Unreachable"></member>
    <member name="T:Llvm.NET.Instructions.ZeroExtend"></member>
    <member name="T:Llvm.NET.Types.IArrayType">
      <summary>Interface for an LLVM array type </summary>
    </member>
    <member name="P:Llvm.NET.Types.IArrayType.Length">
      <summary>Length of the array</summary>
    </member>
    <member name="T:Llvm.NET.Types.IFunctionType">
      <summary>Interface to represent the LLVM type of a function (e.g. a signature)</summary>
    </member>
    <member name="P:Llvm.NET.Types.IFunctionType.IsVarArg">
      <summary>Flag to indicate if this signature is for a variadic function</summary>
    </member>
    <member name="P:Llvm.NET.Types.IFunctionType.ParameterTypes">
      <summary>Collection of types of the parameters for the function</summary>
    </member>
    <member name="P:Llvm.NET.Types.IFunctionType.ReturnType">
      <summary>Return type of the function</summary>
    </member>
    <member name="T:Llvm.NET.Types.IPointerType">
      <summary>Interface for a pointer type in LLVM</summary>
    </member>
    <member name="P:Llvm.NET.Types.IPointerType.AddressSpace">
      <summary>Address space the pointer refers to</summary>
    </member>
    <member name="T:Llvm.NET.Types.ISequenceType">
      <summary>Interface for an LLVM sequence type</summary>
    </member>
    <member name="P:Llvm.NET.Types.ISequenceType.ElementType">
      <summary>Type of elements in the sequence</summary>
    </member>
    <member name="T:Llvm.NET.Types.IStructType">
      <summary>Interface for an LLVM structure type</summary>
    </member>
    <member name="P:Llvm.NET.Types.IStructType.IsOpaque">
      <summary>Indicates if the structure is opaque (e.g. has no body defined yet)</summary>
    </member>
    <member name="P:Llvm.NET.Types.IStructType.IsPacked">
      <summary>Indicates if the structure is packed (e.g. no automatic alignment padding between elements)</summary>
    </member>
    <member name="P:Llvm.NET.Types.IStructType.Members">
      <summary>List of types for all member elements of the structure</summary>
    </member>
    <member name="P:Llvm.NET.Types.IStructType.Name">
      <summary>Name of the structure</summary>
    </member>
    <member name="M:Llvm.NET.Types.IStructType.SetBody(System.Boolean,Llvm.NET.Types.ITypeRef[])">
      <summary>Sets the body of the structure</summary>
      <param name="packed">Flag to indicate if the body elements are packed (e.g. no padding)</param>
      <param name="elements">Optional types of each element</param>
    </member>
    <member name="T:Llvm.NET.Types.ITypeRef">
      <summary>Interface for a Type in LLVM</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.Context">
      <summary>Context that owns this type</summary>
    </member>
    <member name="M:Llvm.NET.Types.ITypeRef.CreateArrayType(System.UInt32)">
      <summary>Array type factory for an array with elements of this type</summary>
      <param name="count">Number of elements in the array</param>
      <returns>
        <see cref="T:Llvm.NET.Types.IArrayType" /> for the array</returns>
    </member>
    <member name="M:Llvm.NET.Types.ITypeRef.CreatePointerType">
      <summary>Get a <see cref="T:Llvm.NET.Types.IPointerType" /> for a type that points to elements of this type in the default (0) address space</summary>
      <returns>
        <see cref="T:Llvm.NET.Types.IPointerType" />corresponding to the type of a pointer that refers to elements of this type</returns>
    </member>
    <member name="M:Llvm.NET.Types.ITypeRef.CreatePointerType(System.UInt32)">
      <summary>Get a <see cref="T:Llvm.NET.Types.IPointerType" /> for a type that points to elements of this type in the specified address space</summary>
      <param name="addressSpace">Address space for the pointer</param>
      <returns>
        <see cref="T:Llvm.NET.Types.IPointerType" />corresponding to the type of a pointer that refers to elements of this type</returns>
    </member>
    <member name="M:Llvm.NET.Types.ITypeRef.GetNullValue">
      <summary>Gets a null value (e.g. all bits == 0 ) for the type</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IntegerBitWidth">
      <summary>Integer bit width of this type or 0 for non integer types</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsDouble"></member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsFloat"></member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsFloatingPoint">
      <summary>Flag to indicate if this type is a floating point type</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsInteger">
      <summary>Flag to indicate if this type is an integer</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsPointer">
      <summary>Flag to indicate if this type is a pointer</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsPointerPointer">
      <summary>FLag to indicate if this type is a pointer to a pointer</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsSequence">
      <summary>Flag to indicate if this type is a sequence type</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsSized">
      <summary>Flag to indicate if the type is sized</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsStruct">
      <summary>Flag to indicate if this type is a structure type</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.IsVoid">
      <summary>Flag to indicate if this type represents the void type</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.Kind">
      <summary>LLVM Type kind for this type</summary>
    </member>
    <member name="P:Llvm.NET.Types.ITypeRef.TypeHandle">
      <summary>LibLLVM handle for the type</summary>
    </member>
    <member name="T:Llvm.NET.Types.IVectorType"></member>
    <member name="P:Llvm.NET.Types.IVectorType.Size"></member>
    <member name="T:Llvm.NET.Values.Argument">
      <summary>An LLVM Value representing an Argument to a function</summary>
    </member>
    <member name="P:Llvm.NET.Values.Argument.Attributes">
      <summary>Attributes for this parameter</summary>
    </member>
    <member name="P:Llvm.NET.Values.Argument.ContainingFunction">
      <summary>Function this argument belongs to</summary>
    </member>
    <member name="P:Llvm.NET.Values.Argument.Index">
      <summary>Zero based index of the argument</summary>
    </member>
    <member name="M:Llvm.NET.Values.Argument.SetAlignment(System.UInt32)">
      <summary>Sets the alignment for the argument</summary>
      <param name="value">Alignment value for this argument</param>
    </member>
    <member name="T:Llvm.NET.Values.AsmDialect"></member>
    <member name="T:Llvm.NET.Values.AttributeBuilder">
      <summary>Factory for building AttributeSets, which are otherwise immutable</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.#ctor">
      <summary>Creates a new empty <see cref="T:Llvm.NET.Values.AttributeBuilder" /> instance</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.#ctor(Llvm.NET.Values.AttributeSet,Llvm.NET.FunctionAttributeIndex)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.AttributeBuilder" /> from a single index of an existing <see cref="T:Llvm.NET.Values.AttributeSet" /></summary>
      <param name="attributes">
        <see cref="T:Llvm.NET.Values.AttributeSet" /> to initialize the builder from</param>
      <param name="index">
        <see cref="T:Llvm.NET.FunctionAttributeIndex" /> to take from <paramref name="attributes" /></param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.#ctor(Llvm.NET.Values.AttributeValue)">
      <summary>Creates a new <see cref="T:Llvm.NET.Values.AttributeBuilder" /> with a given <see cref="T:Llvm.NET.Values.AttributeValue" /></summary>
      <param name="value">
        <see cref="T:Llvm.NET.Values.AttributeValue" /> to add to the builder after creating it</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Add(Llvm.NET.AttributeKind)">
      <summary>Adds a new boolean attribute to this builder</summary>
      <param name="kind">Kind of attribute to add</param>
      <returns>This builder for fluent style programming</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Add(Llvm.NET.Values.AttributeValue)">
      <summary>Adds an <see cref="T:Llvm.NET.Values.AttributeValue" /> to a builder</summary>
      <param name="value">Value to add to this builder</param>
      <returns>This builder for fluent style programming</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Add(System.String)">
      <summary>Adds a target dependent string attribute to a builder</summary>
      <param name="name">Name of the attribute</param>
      <returns>This builder for fluent style programming</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Add(System.String,System.String)">
      <summary>Adds a target dependent attribute to the builder</summary>
      <param name="name">Name of the attribute</param>
      <param name="value">Value of the attribute</param>
      <returns>This builder for fluent style programming</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Contains(Llvm.NET.AttributeKind)">
      <summary>Checks if this builder contains a given boolean attribute</summary>
      <param name="kind">Kind of attribute to test for</param>
      <returns>
        <see langword="true" /> if this builder contains <paramref name="kind" /></returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Contains(System.String)">
      <summary>Checks if this builder contains a given target dependent attribute</summary>
      <param name="name">Kind of attribute to test for</param>
      <returns>
        <see langword="true" /> if this builder contains <paramref name="name" /></returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Dispose">
      <summary>Destroys the underlying native builder</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.HasAttributes(Llvm.NET.Values.AttributeSet,Llvm.NET.FunctionAttributeIndex)">
      <summary>Checks if the builder contains any of the attributes in a given <see cref="T:Llvm.NET.Values.AttributeSet" /></summary>
      <param name="attributes">Attributes to check for</param>
      <param name="index">Index of <paramref name="attributes" /> to use</param>
      <returns>
        <see langword="true" /> if any of the attributes in the specified index of <paramref name="attributes" /> exists in this builder</returns>
    </member>
    <member name="P:Llvm.NET.Values.AttributeBuilder.IsEmpty">
      <summary>Indicates if this Builder contains no attributes</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Merge(Llvm.NET.Values.AttributeBuilder)">
      <summary>Merges the contents of another <see cref="T:Llvm.NET.Values.AttributeBuilder" /> into this one</summary>
      <param name="other">Other <see cref="T:Llvm.NET.Values.AttributeSet" /> to merge into this one</param>
      <returns>This builder for fluent style programming</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Overlaps(Llvm.NET.Values.AttributeBuilder)">
      <summary>Checks if this builder overlaps the attributes in another builder</summary>
      <param name="other">Other builder to check for overlap</param>
      <returns>
        <see langword="true" /> if this builder overlaps <paramref name="other" /></returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Remove(Llvm.NET.AttributeKind)">
      <summary>Removes a boolean attribute from the builder</summary>
      <param name="kind">Kind of attribute to remove</param>
      <returns>This builder for fluent style programming</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Remove(Llvm.NET.Values.AttributeBuilder)">
      <summary>Removes the attributes of another builder from this one</summary>
      <param name="other">builder containing attributes to remove</param>
      <returns>This builder for fluent style programming</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Remove(Llvm.NET.Values.AttributeSet,Llvm.NET.FunctionAttributeIndex)">
      <summary>Removes attributes specified in an <see cref="T:Llvm.NET.Values.AttributeSet" /></summary>
      <param name="attributes">Attributes to remove</param>
      <param name="index">Index of attributes in <paramref name="attributes" /> to remove</param>
      <returns></returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.Remove(System.String)">
      <summary>Removes a target dependent attribute from this builder</summary>
      <param name="name">Name of the attribute to remove</param>
      <returns>This builder for fluent style programming</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.ToAttributeSet(Llvm.NET.FunctionAttributeIndex)">
      <summary>Converts the contents of this builder to an immutable <see cref="T:Llvm.NET.Values.AttributeSet" /></summary>
      <param name="index">Index for the attributes in the new AttributeSet</param>
      <returns>New <see cref="T:Llvm.NET.Values.AttributeSet" /> containing the attributes from this builder in the specified index</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeBuilder.ToAttributeSet(Llvm.NET.FunctionAttributeIndex,Llvm.NET.Context)">
      <summary>Converts the contents of this builder to an immutable <see cref="T:Llvm.NET.Values.AttributeSet" /></summary>
      <param name="index">Index for the attributes in the new AttributeSet</param>
      <param name="context">
        <see cref="T:Llvm.NET.Context" /> to use when building the resulting AttributeSet</param>
      <returns>New <see cref="T:Llvm.NET.Values.AttributeSet" /> containing the attributes from this builder in the specified index</returns>
    </member>
    <member name="T:Llvm.NET.Values.AttributeKindExtensions">
      <summary>Utility class to provide extension methods for validating usage of attribute kinds</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeKindExtensions.CheckAttributeUsage(Llvm.NET.AttributeKind,Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.Function)"></member>
    <member name="M:Llvm.NET.Values.AttributeKindExtensions.GetAllowedIndexes(Llvm.NET.AttributeKind)"></member>
    <member name="M:Llvm.NET.Values.AttributeKindExtensions.RangeCheckValue(Llvm.NET.AttributeKind,System.UInt64)"></member>
    <member name="M:Llvm.NET.Values.AttributeKindExtensions.RequiresIntValue(Llvm.NET.AttributeKind)"></member>
    <member name="M:Llvm.NET.Values.AttributeKindExtensions.VerifyAttributeUsage(Llvm.NET.AttributeKind,Llvm.NET.FunctionAttributeIndex)"></member>
    <member name="M:Llvm.NET.Values.AttributeKindExtensions.VerifyIntAttributeUsage(Llvm.NET.AttributeKind,Llvm.NET.FunctionAttributeIndex,System.UInt64)"></member>
    <member name="T:Llvm.NET.Values.AttributeSet">
      <summary>AttributeSet for a <see cref="T:Llvm.NET.Values.Function" />, <see cref="T:Llvm.NET.Instructions.CallInstruction" />, or <see cref="T:Llvm.NET.Instructions.Invoke" /> instruction</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.#ctor(Llvm.NET.Context,Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeBuilder)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.Values.AttributeSet</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.Add(Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeSet)">
      <summary>Adds Attributes from another attribute set along a given index</summary>
      <param name="index">Index to add attributes to and from</param>
      <param name="attributes">
        <see cref="T:Llvm.NET.Values.AttributeSet" /> to add the attributes from</param>
      <returns>New <see cref="T:Llvm.NET.Values.AttributeSet" />Containing all attributes of this set plus any
             attributes from <paramref name="attributes" /> along the specified <paramref name="index" /></returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.Add(Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeValue)">
      <summary>Adds a single attribute</summary>
      <param name="index">Index for the attribute</param>
      <param name="attribute">
        <see cref="T:Llvm.NET.Values.AttributeValue" /> kind to add</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.Add(Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeValue[])">
      <summary>Adds a set of attributes</summary>
      <param name="index">Index for the attribute</param>
      <param name="attributes">Attributes to add</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.Add(Llvm.NET.FunctionAttributeIndex,System.Collections.Generic.IEnumerable{Llvm.NET.Values.AttributeValue})">
      <summary>Produces a new <see cref="T:Llvm.NET.Values.AttributeSet" /> that includes the attributes from this set along with additional attributes provided</summary>
      <param name="index">
        <see cref="T:Llvm.NET.FunctionAttributeIndex" /> to use for the new attributes</param>
      <param name="attributes">Collection of attributes to add</param>
      <returns>Newly created <see cref="T:Llvm.NET.Values.AttributeSet" />with the new attributes added</returns>
    </member>
    <member name="P:Llvm.NET.Values.AttributeSet.AllAttributes"></member>
    <member name="M:Llvm.NET.Values.AttributeSet.AsString(Llvm.NET.FunctionAttributeIndex)">
      <summary>Get LLVM formatted string representation of this <see cref="T:Llvm.NET.Values.AttributeSet" /> for a given index</summary>
      <param name="index">Index to get the string for</param>
      <returns>Formatted string for the specified attribute index</returns>
    </member>
    <member name="P:Llvm.NET.Values.AttributeSet.Context">
      <summary>Context used to intern this <see cref="T:Llvm.NET.Values.AttributeSet" /></summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.Equals(Llvm.NET.Values.AttributeSet)"></member>
    <member name="M:Llvm.NET.Values.AttributeSet.Equals(System.Object)"></member>
    <member name="P:Llvm.NET.Values.AttributeSet.FunctionAttributes">
      <summary>Gets the attributes for the function itself</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.GetAttributeValue(Llvm.NET.FunctionAttributeIndex,Llvm.NET.AttributeKind)">
      <summary>Get an integer value for an index</summary>
      <param name="index">Index to get the value from</param>
      <param name="kind">
        <see cref="T:Llvm.NET.AttributeKind" /> to get the value of (see remarks for supported attributes)</param>
      <returns>Value of the attribute</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.GetHashCode"></member>
    <member name="M:Llvm.NET.Values.AttributeSet.Has(Llvm.NET.FunctionAttributeIndex,Llvm.NET.AttributeKind)">
      <summary>Tests if this attribute set has a given AttributeValue kind</summary>
      <param name="index">Index for the attribute</param>
      <param name="kind">Kind of AttributeValue to test for</param>
      <returns>true if the AttributeValue exists or false if not</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.Has(Llvm.NET.FunctionAttributeIndex,System.String)">
      <summary>Tests if this attribute set has a given string attribute</summary>
      <param name="index">Index for the attribute</param>
      <param name="name">Name of the attribute to test for</param>
      <returns>true if the attribute exists or false if not</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.HasAny(Llvm.NET.FunctionAttributeIndex)">
      <summary>Tests if an <see cref="T:Llvm.NET.Values.AttributeSet" /> has any attributes in the specified index</summary>
      <param name="index">Index for the attribute</param>
    </member>
    <member name="P:Llvm.NET.Values.AttributeSet.Indexes">
      <summary>Enumerates the <see cref="T:Llvm.NET.FunctionAttributeIndex" /> values that have attributes associated in this <see cref="T:Llvm.NET.Values.AttributeSet" /></summary>
    </member>
    <member name="P:Llvm.NET.Values.AttributeSet.Item(Llvm.NET.FunctionAttributeIndex)">
      <summary>Retrieves an attributeSet filtered by the specified function index</summary>
      <param name="index">Index to filter on</param>
      <returns>A new <see cref="T:Llvm.NET.Values.AttributeSet" />with attributes from this set belonging to the specified index</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.op_Equality(Llvm.NET.Values.AttributeSet,Llvm.NET.Values.AttributeSet)"></member>
    <member name="M:Llvm.NET.Values.AttributeSet.op_Inequality(Llvm.NET.Values.AttributeSet,Llvm.NET.Values.AttributeSet)"></member>
    <member name="M:Llvm.NET.Values.AttributeSet.ParameterAttributes(System.Int32)">
      <summary>Gets the attributes for a function parameter</summary>
      <param name="parameterIndex">Parameter index [ 0 based ]</param>
      <returns>
        <see cref="T:Llvm.NET.Values.AttributeSet" />filtered for the specified parameter</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.Remove(Llvm.NET.FunctionAttributeIndex,Llvm.NET.AttributeKind)">
      <summary>Removes the specified attribute from the attribute set</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.Remove(Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeBuilder)"></member>
    <member name="M:Llvm.NET.Values.AttributeSet.Remove(Llvm.NET.FunctionAttributeIndex,System.String)">
      <summary>Remove a target specific attribute</summary>
      <param name="index">Index for the attribute</param>
      <param name="name">Name of the attribute</param>
    </member>
    <member name="P:Llvm.NET.Values.AttributeSet.ReturnAttributes">
      <summary>Gets the attributes for the function return</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSet.ToString">
      <summary>Creates a formatted string representation of the entire <see cref="T:Llvm.NET.Values.AttributeSet" /> (e.g. all indices)</summary>
      <returns>Formatted string representation of the <see cref="T:Llvm.NET.Values.AttributeSet" /></returns>
    </member>
    <member name="T:Llvm.NET.Values.AttributeSetContainer">
      <summary>Static class to provide mutators for otherwise immutable <see cref="T:Llvm.NET.Values.AttributeSet" />s</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.AddAttribute``1(``0,Llvm.NET.FunctionAttributeIndex,Llvm.NET.AttributeKind)"></member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.AddAttribute``1(``0,Llvm.NET.FunctionAttributeIndex,Llvm.NET.AttributeKind[])"></member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.AddAttribute``1(``0,Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeValue)"></member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.AddAttributes(Llvm.NET.Values.Function,Llvm.NET.Values.AttributeValue[])">
      <summary>Compatibility extension method to handle migrating code from older attribute handling</summary>
      <param name="self">Function to add attributes to</param>
      <param name="attributes">Attributes to add</param>
      <returns>The function itself</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.AddAttributes(Llvm.NET.Values.Function,System.Collections.Generic.IEnumerable{Llvm.NET.Values.AttributeValue})">
      <summary>Compatibility extension method to handle migrating code from older attribute handling</summary>
      <param name="self">Function to add attributes to</param>
      <param name="attributes">Attributes to add</param>
      <returns>The function itself</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.AddAttributes``1(``0,Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeSet)"></member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.AddAttributes``1(``0,Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeValue[])"></member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.AddAttributes``1(``0,Llvm.NET.FunctionAttributeIndex,System.Collections.Generic.IEnumerable{Llvm.NET.Values.AttributeValue})"></member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.RemoveAttribute(Llvm.NET.Values.Function,Llvm.NET.AttributeKind)">
      <summary>Compatibility extension method to handle migrating code from older attribute handling</summary>
      <param name="self">Function to remove attributes from</param>
      <param name="kind">Attribute to remove</param>
      <returns>The function itself</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.RemoveAttribute(Llvm.NET.Values.Function,System.String)">
      <summary>Compatibility extension method to handle migrating code from older attribute handling</summary>
      <param name="self">Function to remove attributes from</param>
      <param name="name">Attribute to remove</param>
      <returns>The function itself</returns>
    </member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.RemoveAttribute``1(``0,Llvm.NET.FunctionAttributeIndex,Llvm.NET.AttributeKind)"></member>
    <member name="M:Llvm.NET.Values.AttributeSetContainer.RemoveAttribute``1(``0,Llvm.NET.FunctionAttributeIndex,System.String)"></member>
    <member name="T:Llvm.NET.Values.AttributeValue">
      <summary>Single attribute for functions, function returns and function parameters</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.#ctor(Llvm.NET.AttributeKind)">
      <summary>Creates a simple boolean attribute</summary>
      <param name="kind">Kind of attribute</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.#ctor(Llvm.NET.AttributeKind,System.UInt64)">
      <summary>Creates an attribute with an integer value parameter</summary>
      <param name="kind">The kind of attribute</param>
      <param name="value">Value for the attribute</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.#ctor(Llvm.NET.Context,Llvm.NET.AttributeKind)">
      <summary>Creates a simple boolean attribute</summary>
      <param name="context">Context for creating the attribute</param>
      <param name="kind">Kind of attribute</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.#ctor(Llvm.NET.Context,Llvm.NET.AttributeKind,System.UInt64)">
      <summary>Creates an attribute with an integer value parameter</summary>
      <param name="context">Context used for interning attributes</param>
      <param name="kind">The kind of attribute</param>
      <param name="value">Value for the attribute</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.#ctor(Llvm.NET.Context,System.String)">
      <summary>Adds a valueless named attribute</summary>
      <param name="context">Context to use for interning attributes</param>
      <param name="name">Attribute name</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.#ctor(Llvm.NET.Context,System.String,System.String)">
      <summary>Adds a Target specific named attribute with value</summary>
      <param name="context">Context to use for interning attributes</param>
      <param name="name">Name of the attribute</param>
      <param name="value">Value of the attribute</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.#ctor(System.String)">
      <summary>Adds a valueless named attribute</summary>
      <param name="name">Attribute name</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.#ctor(System.String,System.String)">
      <summary>Adds a Target specific named attribute with value</summary>
      <param name="name">Name of the attribute</param>
      <param name="value">Value of the attribute</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.Equals(Llvm.NET.Values.AttributeValue)"></member>
    <member name="M:Llvm.NET.Values.AttributeValue.Equals(System.Object)"></member>
    <member name="M:Llvm.NET.Values.AttributeValue.GetHashCode"></member>
    <member name="P:Llvm.NET.Values.AttributeValue.IntegerValue">
      <summary>Integer value of the attribute or null if the attribute doesn't have a value</summary>
    </member>
    <member name="P:Llvm.NET.Values.AttributeValue.IsEnum">
      <summary>Flag to indicate if this attribute is a simple enumeration value</summary>
    </member>
    <member name="P:Llvm.NET.Values.AttributeValue.IsInt">
      <summary>Flag to indicate if this attribute has an integer attribute</summary>
    </member>
    <member name="P:Llvm.NET.Values.AttributeValue.IsString">
      <summary>Flag to indicate if this attribute is a target specific string value</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.IsValidOn(Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.Function)"></member>
    <member name="P:Llvm.NET.Values.AttributeValue.Kind">
      <summary>Kind of the attribute, or null for target specif named attributes</summary>
    </member>
    <member name="P:Llvm.NET.Values.AttributeValue.Name">
      <summary>Name of a named attribute or null for other kinds of attributes</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.op_Equality(Llvm.NET.Values.AttributeValue,Llvm.NET.Values.AttributeValue)"></member>
    <member name="M:Llvm.NET.Values.AttributeValue.op_Implicit(Llvm.NET.AttributeKind)~Llvm.NET.Values.AttributeValue">
      <summary>Implicitly cast an <see cref="T:Llvm.NET.AttributeKind" /> to an <see cref="T:Llvm.NET.Values.AttributeValue" /></summary>
      <param name="kind">Kind of attribute to create</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.op_Implicit(System.String)~Llvm.NET.Values.AttributeValue">
      <summary>Implicitly cast a string to an named <see cref="T:Llvm.NET.Values.AttributeValue" /></summary>
      <param name="kind">Attribute name</param>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.op_Inequality(Llvm.NET.Values.AttributeValue,Llvm.NET.Values.AttributeValue)"></member>
    <member name="P:Llvm.NET.Values.AttributeValue.StringValue">
      <summary>StringValue for named attributes with values</summary>
    </member>
    <member name="M:Llvm.NET.Values.AttributeValue.ToString"></member>
    <member name="T:Llvm.NET.Values.BasicBlock">
      <summary>Provides access to an LLVM Basic block</summary>
    </member>
    <member name="P:Llvm.NET.Values.BasicBlock.ContainingFunction">
      <summary>Function containing the block</summary>
    </member>
    <member name="P:Llvm.NET.Values.BasicBlock.FirstInstruction">
      <summary>First instruction in the block</summary>
    </member>
    <member name="M:Llvm.NET.Values.BasicBlock.GetNextInstruction(Llvm.NET.Instructions.Instruction)">
      <summary>Gets the instruction that follows a given instruction in a block</summary>
      <param name="instruction">instruction in the block to get the next instruction from</param>
      <returns>Next instruction or null if none</returns>
      <exception cref="T:System.ArgumentException">Thrown when <paramref cref="T:Llvm.NET.Instructions.Instruction" /> is from a different block</exception>
    </member>
    <member name="P:Llvm.NET.Values.BasicBlock.Instructions">
      <summary>Enumerable collection of all instructions in the block</summary>
    </member>
    <member name="P:Llvm.NET.Values.BasicBlock.LastInstruction">
      <summary>Last instruction in the block</summary>
    </member>
    <member name="P:Llvm.NET.Values.BasicBlock.Terminator">
      <summary>Terminator instruction for the block</summary>
    </member>
    <member name="T:Llvm.NET.Values.BlockAddress"></member>
    <member name="T:Llvm.NET.Values.Constant">
      <summary>Contains an LLVM Constant value</summary>
    </member>
    <member name="M:Llvm.NET.Values.Constant.AllOnesValueFor(Llvm.NET.Types.ITypeRef)">
      <summary>Creates a constant instance of <paramref name="typeRef" /> with all bits in the instance set to 1</summary>
      <param name="typeRef">Type of value to create</param>
      <returns>Constant for the type with all instance bits set to 1</returns>
    </member>
    <member name="M:Llvm.NET.Values.Constant.ConstPointerToNullFor(Llvm.NET.Types.ITypeRef)">
      <summary>Create a constant NULL pointer for a given type</summary>
      <param name="typeRef">Type of pointer to create a null value for</param>
      <returns>Constant NULL pointer of the specified type</returns>
    </member>
    <member name="P:Llvm.NET.Values.Constant.IsZeroValue">
      <summary>Indicates if the constant is a Zero value for the its type</summary>
    </member>
    <member name="M:Llvm.NET.Values.Constant.NullValueFor(Llvm.NET.Types.ITypeRef)">
      <summary>Create a NULL pointer for a given type</summary>
      <param name="typeRef">Type of pointer to create a null vale for</param>
      <returns>Constant NULL pointer of the specified type</returns>
    </member>
    <member name="M:Llvm.NET.Values.Constant.UndefinedValueFor(Llvm.NET.Types.ITypeRef)">
      <summary>Creates an <see cref="T:Llvm.NET.Values.Constant" /> representing an undefined value for <paramref name="typeRef" /></summary>
      <param name="typeRef">Type to create the undefined value for</param>
      <returns>
        <see cref="T:Llvm.NET.Values.Constant" /> representing an undefined value of <paramref name="typeRef" /></returns>
    </member>
    <member name="T:Llvm.NET.Values.ConstantAggregateZero"></member>
    <member name="T:Llvm.NET.Values.ConstantArray">
      <summary>LLVM Constant Array</summary>
    </member>
    <member name="M:Llvm.NET.Values.ConstantArray.From(Llvm.NET.Types.ITypeRef,Llvm.NET.Values.Constant[])">
      <summary>Create a constant array of values of a given type</summary>
      <param name="elementType">Type of elements in the array</param>
      <param name="values">Values to initialize the array</param>
      <returns>Constant representing the array</returns>
    </member>
    <member name="M:Llvm.NET.Values.ConstantArray.From(Llvm.NET.Types.ITypeRef,System.Collections.Generic.IList{Llvm.NET.Values.Constant})">
      <summary>Create a constant array of values of a given type</summary>
      <param name="elementType">Type of elements in the array</param>
      <param name="values">Values to initialize the array</param>
      <returns>Constant representing the array</returns>
    </member>
    <member name="M:Llvm.NET.Values.ConstantArray.From(Llvm.NET.Types.ITypeRef,System.Int32,Llvm.NET.Values.Constant[])">
      <summary>Create a constant array of values of a given type with a fixed size, zero filling any un-specified values</summary>
      <param name="elementType">Type of elements in the array</param>
      <param name="len">Length of the array</param>
      <param name="values">Values to initialize the array</param>
      <returns>Constant representing the array</returns>
    </member>
    <member name="T:Llvm.NET.Values.ConstantDataArray"></member>
    <member name="T:Llvm.NET.Values.ConstantDataSequential">
      <summary>
            A vector or array constant whose element type is a simple 1/2/4/8-byte integer
            or float/double, and whose elements are just  simple data values
            (i.e. ConstantInt/ConstantFP).
            </summary>
    </member>
    <member name="M:Llvm.NET.Values.ConstantDataSequential.ExtractAsString"></member>
    <member name="P:Llvm.NET.Values.ConstantDataSequential.IsString"></member>
    <member name="T:Llvm.NET.Values.ConstantDataVector"></member>
    <member name="T:Llvm.NET.Values.ConstantExpression">
      <summary>While technically a type in LLVM, ConstantExpression is primarily a static factory for Constants</summary>
    </member>
    <member name="M:Llvm.NET.Values.ConstantExpression.BitCast(Llvm.NET.Values.Constant,Llvm.NET.Types.ITypeRef)"></member>
    <member name="M:Llvm.NET.Values.ConstantExpression.GetElementPtr(Llvm.NET.Values.Constant,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Constant})"></member>
    <member name="M:Llvm.NET.Values.ConstantExpression.IntToPtrExpression(Llvm.NET.Values.Constant,Llvm.NET.Types.ITypeRef)"></member>
    <member name="P:Llvm.NET.Values.ConstantExpression.OpCode"></member>
    <member name="T:Llvm.NET.Values.ConstantFP">
      <summary>Floating point constant value in LLVM</summary>
    </member>
    <member name="M:Llvm.NET.Values.ConstantFP.GetValueWithLoss(System.Boolean@)"></member>
    <member name="P:Llvm.NET.Values.ConstantFP.Value"></member>
    <member name="T:Llvm.NET.Values.ConstantInt">
      <summary>Represents an arbitrary bit width integer constant in LLVM</summary>
    </member>
    <member name="P:Llvm.NET.Values.ConstantInt.SignExtendedValue">
      <summary>Sign extends the value to a 64 bit value</summary>
    </member>
    <member name="P:Llvm.NET.Values.ConstantInt.ZeroExtendedValue">
      <summary>Retrieves the value of the constant zero extended to 64 bits</summary>
    </member>
    <member name="T:Llvm.NET.Values.ConstantPointerNull"></member>
    <member name="M:Llvm.NET.Values.ConstantPointerNull.From(Llvm.NET.Types.ITypeRef)">
      <summary>Creates a constant null pointer to a given type</summary>
      <param name="type"></param>
      <returns></returns>
    </member>
    <member name="T:Llvm.NET.Values.ConstantStruct"></member>
    <member name="T:Llvm.NET.Values.ConstantTokenNone"></member>
    <member name="T:Llvm.NET.Values.ConstantVector"></member>
    <member name="T:Llvm.NET.Values.Function">
      <summary>LLVM Function definition</summary>
    </member>
    <member name="M:Llvm.NET.Values.Function.AppendBasicBlock(System.String)">
      <summary>Appends a new basic block to a function</summary>
      <param name="name">Name (label) of the block</param>
      <returns>
        <see cref="T:Llvm.NET.Values.BasicBlock" /> created and inserted onto the end of the function</returns>
    </member>
    <member name="P:Llvm.NET.Values.Function.Attributes"></member>
    <member name="P:Llvm.NET.Values.Function.BasicBlocks">
      <summary>Basic Blocks for the function</summary>
    </member>
    <member name="P:Llvm.NET.Values.Function.CallingConvention">
      <summary>Calling convention for the method</summary>
    </member>
    <member name="P:Llvm.NET.Values.Function.DISubProgram">
      <summary>Debug information for this function</summary>
    </member>
    <member name="P:Llvm.NET.Values.Function.EntryBlock">
      <summary>Entry block for this function</summary>
    </member>
    <member name="M:Llvm.NET.Values.Function.FindOrCreateNamedBlock(System.String)">
      <summary>Retrieves or creates  block by name</summary>
      <param name="name">Block name (label) to look for or create</param>
      <returns>
        <see cref="T:Llvm.NET.Values.BasicBlock" /> If the block was created it is appended to the end of function</returns>
    </member>
    <member name="P:Llvm.NET.Values.Function.GcName">
      <summary>Garbage collection engine name that this function is generated to work with</summary>
    </member>
    <member name="P:Llvm.NET.Values.Function.IntrinsicId">
      <summary>LLVM instrinsicID for the method</summary>
    </member>
    <member name="P:Llvm.NET.Values.Function.IsVarArg">
      <summary>Flag to indicate if the method signature accepts variable arguments</summary>
    </member>
    <member name="P:Llvm.NET.Values.Function.Parameters">
      <summary>Parameters for the function including any method definition specific attributes (i.e. ByVal)</summary>
    </member>
    <member name="P:Llvm.NET.Values.Function.PersonalityFunction"></member>
    <member name="M:Llvm.NET.Values.Function.PrependBasicBlock(System.String)">
      <summary>Add a new basic block to the beginning of a function</summary>
      <param name="name">Name (label) for the block</param>
      <returns>
        <see cref="T:Llvm.NET.Values.BasicBlock" /> created and inserted at the beginning of the function</returns>
    </member>
    <member name="P:Llvm.NET.Values.Function.ReturnType">
      <summary>Return type of the function</summary>
    </member>
    <member name="P:Llvm.NET.Values.Function.Signature">
      <summary>Signature type of the function</summary>
    </member>
    <member name="M:Llvm.NET.Values.Function.Verify">
      <summary>Verifies the function is valid and all blocks properly terminated</summary>
    </member>
    <member name="T:Llvm.NET.Values.FunctionIndexKinds">
      <summary>Enumeration flags to indicate which attribute set index an attribute may apply to</summary>
    </member>
    <member name="F:Llvm.NET.Values.FunctionIndexKinds.None">
      <summary>Invalid attributes don't apply to any index</summary>
    </member>
    <member name="F:Llvm.NET.Values.FunctionIndexKinds.Function">
      <summary>The attribute is applicable to a function</summary>
    </member>
    <member name="F:Llvm.NET.Values.FunctionIndexKinds.Return">
      <summary>The attribute is applicable to a function's return</summary>
    </member>
    <member name="F:Llvm.NET.Values.FunctionIndexKinds.Parameter">
      <summary>The attribute is applicable to a function's parameter</summary>
    </member>
    <member name="T:Llvm.NET.Values.GlobalAlias">
      <summary>LLVM Global Alias for a function or global value</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalAlias.Aliasee"></member>
    <member name="T:Llvm.NET.Values.GlobalObject"></member>
    <member name="P:Llvm.NET.Values.GlobalObject.Alignment">
      <summary>Alignment requirements for this object</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalObject.Section">
      <summary>Linker section this object belongs to</summary>
    </member>
    <member name="T:Llvm.NET.Values.GlobalValue">
      <summary>LLVM Global value </summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalValue.IsDeclaration">
      <summary>Flag to indicate if this is a declaration</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalValue.Linkage">
      <summary>Linkage specification for this symbol</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalValue.ParentModule">
      <summary>Module containing this global value</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalValue.UnnamedAddress">
      <summary>Flag to indicate if this is an Unnamed address</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalValue.Visibility">
      <summary>Visibility of this global value</summary>
    </member>
    <member name="T:Llvm.NET.Values.GlobalValueExtensions"></member>
    <member name="M:Llvm.NET.Values.GlobalValueExtensions.Linkage``1(``0,Llvm.NET.Linkage)">
      <summary>Linkage specification for this symbol</summary>
    </member>
    <member name="M:Llvm.NET.Values.GlobalValueExtensions.Visibility``1(``0,Llvm.NET.Visibility)">
      <summary>Visibility of this global value</summary>
    </member>
    <member name="T:Llvm.NET.Values.GlobalVariable">
      <summary>An LLVM Global Variable</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalVariable.Initializer">
      <summary>Initial value for the variable</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalVariable.IsConstant">
      <summary>Gets or sets if this global is a Constant</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalVariable.IsExternallyInitialized">
      <summary>Flag to indicate if this variable is initialized in an external module</summary>
    </member>
    <member name="P:Llvm.NET.Values.GlobalVariable.IsThreadLocal">
      <summary>Flag to indicate if this global is stored per thread</summary>
    </member>
    <member name="M:Llvm.NET.Values.GlobalVariable.RemoveFromParent">
      <summary>Removes the value from its parent module, but does not delete it</summary>
    </member>
    <member name="T:Llvm.NET.Values.IAttributeSetContainer">
      <summary>Interface for values containing an AttributeSet</summary>
    </member>
    <member name="P:Llvm.NET.Values.IAttributeSetContainer.Attributes">
      <summary>Attributes for this container</summary>
    </member>
    <member name="T:Llvm.NET.Values.IndexedAttributeValue"></member>
    <member name="M:Llvm.NET.Values.IndexedAttributeValue.#ctor(Llvm.NET.FunctionAttributeIndex,Llvm.NET.Values.AttributeValue)">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Llvm.NET.Values.IndexedAttributeValue</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Llvm.NET.Values.IndexedAttributeValue.Equals(Llvm.NET.Values.IndexedAttributeValue)"></member>
    <member name="M:Llvm.NET.Values.IndexedAttributeValue.Equals(System.Object)"></member>
    <member name="M:Llvm.NET.Values.IndexedAttributeValue.GetHashCode"></member>
    <member name="P:Llvm.NET.Values.IndexedAttributeValue.Index"></member>
    <member name="M:Llvm.NET.Values.IndexedAttributeValue.op_Equality(Llvm.NET.Values.IndexedAttributeValue,Llvm.NET.Values.IndexedAttributeValue)"></member>
    <member name="M:Llvm.NET.Values.IndexedAttributeValue.op_Inequality(Llvm.NET.Values.IndexedAttributeValue,Llvm.NET.Values.IndexedAttributeValue)"></member>
    <member name="M:Llvm.NET.Values.IndexedAttributeValue.ToString"></member>
    <member name="P:Llvm.NET.Values.IndexedAttributeValue.Value"></member>
    <member name="T:Llvm.NET.Values.InlineAsm"></member>
    <member name="T:Llvm.NET.Values.UndefValue"></member>
    <member name="T:Llvm.NET.Values.Use">
      <summary>LLVM Use, which is essentially a tuple of the <see cref="P:Llvm.NET.Values.Use.User" /> and the <see cref="P:Llvm.NET.Values.Use.Value" /> used</summary>
    </member>
    <member name="P:Llvm.NET.Values.Use.User"></member>
    <member name="P:Llvm.NET.Values.Use.Value"></member>
    <member name="T:Llvm.NET.Values.User">
      <summary>Contains an LLVM User value</summary>
    </member>
    <member name="P:Llvm.NET.Values.User.Operands">
      <summary>Collection of operands</summary>
    </member>
    <member name="P:Llvm.NET.Values.User.Uses">
      <summary>Enumerable collection of <see cref="T:Llvm.NET.Values.Use" />s</summary>
    </member>
    <member name="T:Llvm.NET.Values.Value">
      <summary>LLVM Value</summary>
    </member>
    <member name="M:Llvm.NET.Values.Value.AddExtendedPropertyValue(System.String,System.Object)">
      <summary>Adds a value to the container</summary>
      <param name="id">Id of the value</param>
      <param name="value">value to add</param>
    </member>
    <member name="P:Llvm.NET.Values.Value.Context"></member>
    <member name="P:Llvm.NET.Values.Value.IsNull">
      <summary>Determines if the Value represents the NULL value for the values type</summary>
    </member>
    <member name="P:Llvm.NET.Values.Value.IsUndefined">
      <summary>Indicates if this value is Undefined</summary>
    </member>
    <member name="P:Llvm.NET.Values.Value.Name">
      <summary>Name of the value (if any)</summary>
    </member>
    <member name="P:Llvm.NET.Values.Value.NativeType">
      <summary>Type of the value</summary>
    </member>
    <member name="M:Llvm.NET.Values.Value.ReplaceAllUsesWith(Llvm.NET.Values.Value)">
      <summary>Replace all uses of a <see cref="T:Llvm.NET.Values.Value" /> with another one</summary>
      <param name="other">New value</param>
    </member>
    <member name="M:Llvm.NET.Values.Value.ToString">
      <summary>Generates a string representing the LLVM syntax of the value</summary>
      <returns>string version of the value formatted by LLVM</returns>
    </member>
    <member name="M:Llvm.NET.Values.Value.TryGetExtendedPropertyValue``1(System.String,``0@)">
      <summary>Try to get a value from the container</summary>
      <param name="id">id of the value to retrieve</param>
      <param name="value">value retrieved if present (or default value of type <typeparamref name="T" /> otherwise)</param>
      <typeparam name="T">Type of value to retrieve</typeparam>
      <returns>
            true if the item was found and it's type matches <typeparamref name="T" /> false otherwise.
            </returns>
    </member>
    <member name="T:Llvm.NET.Values.ValueExtensions">
      <summary>Provides extension methods to <see cref="T:Llvm.NET.Values.Value" /> that cannot be achieved as members of the class</summary>
    </member>
    <member name="M:Llvm.NET.Values.ValueExtensions.RegisterName``1(``0,System.String)">
      <summary>Sets the virtual register name for a value</summary>
      <param name="value">Value to set register name for</param>
      <param name="name">Name for the virtual register the value represents</param>
      <typeparam name="T"> Type of the value to set the name for</typeparam>
    </member>
    <member name="M:Llvm.NET.Values.ValueExtensions.SetDebugLocation``1(``0,Llvm.NET.DebugInfo.DILocation)">
      <summary>Sets the debugging location for a value</summary>
      <param name="value">Value to set debug location for</param>
      <param name="location">Debug location information</param>
      <typeparam name="T"> Type of the value to tag</typeparam>
    </member>
    <member name="M:Llvm.NET.Values.ValueExtensions.SetDebugLocation``1(``0,System.UInt32,System.UInt32,Llvm.NET.DebugInfo.DILocalScope)">
      <summary>Sets the debugging location for a value</summary>
      <param name="value">Value to set debug location for</param>
      <param name="line">Line number</param>
      <param name="column">Column number</param>
      <param name="scope">Scope for the value</param>
      <typeparam name="T"> Type of the value to tag</typeparam>
    </member>
  </members>
</doc>